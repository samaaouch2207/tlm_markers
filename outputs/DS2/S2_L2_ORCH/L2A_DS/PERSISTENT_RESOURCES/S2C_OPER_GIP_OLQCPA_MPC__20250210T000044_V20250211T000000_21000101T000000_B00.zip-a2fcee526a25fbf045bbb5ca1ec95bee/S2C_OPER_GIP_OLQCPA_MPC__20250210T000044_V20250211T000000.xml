<?xml version="1.0" encoding="UTF-8"?>
<Earth_Explorer_File xmlns="http://pdgs.s2.esa.int/S2/PDGS/1.0/olqc/gipp"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pdgs.s2.esa.int/S2/PDGS/1.0/olqc/gipp">
   <Earth_Explorer_Header>
      <Fixed_Header>
         <File_Name>S2C_OPER_GIP_OLQCPA_MPC__20250210T000044_V20250211T000000</File_Name>
         <File_Description>File used to configure Amalfi</File_Description>
         <Notes>Remove the three checks Geometric_Refining*, as useless</Notes>
         <Mission>S2C</Mission>
         <File_Class>OPER</File_Class>
         <File_Type>GIP_OLQCPA</File_Type>
         <Validity_Period>
            <Validity_Start>UTC=2025-02-11T00:00:00</Validity_Start>
            <Validity_Stop>UTC=2100-01-01T00:00:00</Validity_Stop>
         </Validity_Period>
         <File_Version>0044</File_Version>
         <Source>
            <System>MPC_</System>
            <Creator>MPC</Creator>
            <Creator_Version>1.0</Creator_Version>
            <Creation_Date>UTC=2025-02-10T00:00:44</Creation_Date>
         </Source>
      </Fixed_Header>
   </Earth_Explorer_Header>
   <Data_Block type="xml">
      <olqcGipp version="1.0"
         name="Online Quality Control processing parameter file">
         <items>
            <item id="http://www.esa.int/s2#pdiTar">
               <name>pdiTar</name>
               <checklist id="pdiTar_concluding_checklist" category="concluding">
                  <name>pdiTar concluding checklist</name>
                  <inspectionReference reference="testSize" />
                  <inspectionsOf><![CDATA[
                     (*, IMG_DATA/*)
                  ]]></inspectionsOf>
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_0_container">
               <name>pdi_level_0_container</name>
               <checklist id="pdi_level_0_container_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_0_container concluding checklist</name>
                  <inspectionReference reference="checkSafeManifest" />
                  <inspectionReference reference="checkMetadata" />

                  <inspectionReference reference="acquisitionPeriodExists" />
                  <inspectionReference reference="processingExists" />
                  <inspectionReference reference="acquisitionPeriodCategory" />
                  <inspectionReference reference="acquisitionPeriodClassification" />
                  <inspectionReference reference="processingCategory" />
                  <inspectionReference reference="processingClassification" />
                  <inspectionReference reference="platformCategory" />
                  <inspectionReference reference="platformClassification" />
                  <inspectionReference reference="schemaCategory" />
                  <inspectionReference reference="schemaClassification" />
                  <inspectionReference reference="annotationCategory" />
                  <inspectionReference reference="annotationClassification" />
                  <inspectionReference reference="frameSetCategory" />
                  <inspectionReference reference="frameSetClassification" />
                  <inspectionReference reference="gridReferenceCategory" />
                  <inspectionReference reference="gridReferenceClassification" />
                  <inspectionReference reference="indexCategory" />
                  <inspectionReference reference="indexClassification" />
                  <inspectionReference reference="informationCategory" />
                  <inspectionReference reference="informationClassification" />
                  <inspectionReference reference="orbitReferenceCategory" />
                  <inspectionReference reference="orbitReferenceClassification" />
                  <inspectionReference reference="qualityInformationCategory" />
                  <inspectionReference reference="qualityInformationClassification" />
                  <inspectionReference reference="idReferences" />
                  <inspectionReference reference="extraData" />
                  <inspectionReference reference="hrefExist" />

                  <inspectionsOf><![CDATA[
                     (*, IMG_DATA/*)
                  ]]></inspectionsOf>
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_1_container">
               <name>pdi_level_1_container</name>
               <checklist id="pdi_level_1_container_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_1_container concluding checklist</name>
                  <inspectionReference reference="checkSafeManifest" />
                  <inspectionReference reference="checkMetadata" />

                  <inspectionReference reference="acquisitionPeriodExists" />
                  <inspectionReference reference="processingExists" />
                  <inspectionReference reference="acquisitionPeriodCategory" />
                  <inspectionReference reference="acquisitionPeriodClassification" />
                  <inspectionReference reference="processingCategory" />
                  <inspectionReference reference="processingClassification" />
                  <inspectionReference reference="platformCategory" />
                  <inspectionReference reference="platformClassification" />
                  <inspectionReference reference="schemaCategory" />
                  <inspectionReference reference="schemaClassification" />
                  <inspectionReference reference="annotationCategory" />
                  <inspectionReference reference="annotationClassification" />
                  <inspectionReference reference="frameSetCategory" />
                  <inspectionReference reference="frameSetClassification" />
                  <inspectionReference reference="gridReferenceCategory" />
                  <inspectionReference reference="gridReferenceClassification" />
                  <inspectionReference reference="indexCategory" />
                  <inspectionReference reference="indexClassification" />
                  <inspectionReference reference="informationCategory" />
                  <inspectionReference reference="informationClassification" />
                  <inspectionReference reference="orbitReferenceCategory" />
                  <inspectionReference reference="orbitReferenceClassification" />
                  <inspectionReference reference="qualityInformationCategory" />
                  <inspectionReference reference="qualityInformationClassification" />
                  <inspectionReference reference="idReferences" />
                  <inspectionReference reference="extraData" />
                  <inspectionReference reference="hrefExist" />

                  <inspectionsOf><![CDATA[
                     (*, IMG_DATA/*)
                  ]]></inspectionsOf>
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_2_container">
               <name>pdi_level_2_container</name>
               <checklist id="pdi_level_2_container_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_2_container concluding checklist</name>
                  <inspectionReference reference="checkMetadata" />
                  <inspectionsOf><![CDATA[
                     (*, IMG_DATA/R10m/*, IMG_DATA/R20m/*, IMG_DATA/R60m/*)
                  ]]></inspectionsOf>
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_1a_granule_container">
               <name>pdi_level_1a_granule_container</name>
               <checklist id="pdi_level_1a_granule_container_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_1a_granule_container concluding checklist</name>
                  <inspectionReference reference="Granule_Dimensions_10m" />
                  <inspectionReference reference="Granule_Dimensions_20m" />
                  <inspectionReference reference="Granule_Dimensions_60m" />
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_1b_granule_container">
               <name>pdi_level_1b_granule_container</name>
               <checklist id="pdi_level_1b_granule_container_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_1b_granule_container concluding checklist</name>
                  <inspectionReference reference="Granule_Dimensions_10m" />
                  <inspectionReference reference="Granule_Dimensions_20m" />
                  <inspectionReference reference="Granule_Dimensions_60m" />
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_1c_tile_container">
               <name>pdi_level_1c_tile_container</name>
               <checklist id="pdi_level_1c_tile_container_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_1c_tile_container concluding checklist</name>
                  <inspectionReference reference="Granule_Dimensions_10m" />
                  <inspectionReference reference="Granule_Dimensions_20m" />
                  <inspectionReference reference="Granule_Dimensions_60m" />
                  <inspectionReference reference="PVI_and_TCI" />
                  <inspectionReference reference="Ecmwf" />
		  <inspectionReference reference="Aux_Cams" />
                  <inspectionReference reference="Data_Loss" />
                  <inspectionReference reference="checkL1CMasks" />
               </checklist>
            </item>

            <item id="http://www.esa.int/s2#pdi_level_2a_tile_container">
               <name>pdi_level_2a_tile_container</name>
               <checklist id="pdi_level_2a_tile_container_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_2a_tile_container concluding checklist</name>
                  <inspectionReference reference="Granule_Dimensions_10m" />
                  <inspectionReference reference="Granule_Dimensions_20m" />
                  <inspectionReference reference="Granule_Dimensions_60m" />
                  <inspectionReference reference="Ecmwf" />
		  <inspectionReference reference="Aux_Cams" />
                  <inspectionReference reference="Data_Loss" />
                  <inspectionReference reference="checkL2AImages" />
                  <inspectionReference reference="checkL2AMasks" />
               </checklist>
            </item>

            <item id="http://www.esa.int/s2#pdi_level_0_granule_metadata">
               <name>pdi_level_0_granule_metadata</name>
               <checklist id="pdi_level_0_granule_metadata_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_0_granule_metadata concluding checklist</name>
                  <inspectionReference reference="Corrupted_ISP" />
                  <inspectionReference reference="Sensing_Time" />
                  <inspectionReference reference="Missing_Lines" />
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_0_datastrip_metadata">
               <name>pdi_level_0_datastrip_metadata</name>
               <checklist id="pdi_level_0_datastrip_metadata_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_0_datastrip_metadata concluding checklist</name>
                  <inspectionReference reference="Lost_Packets" />
                  <inspectionReference reference="Degraded_Packets" />
                  <inspectionReference reference="Datation_Model_RMOY" />
                  <inspectionReference reference="Datation_Model_GPS_SYNC" />
                  <inspectionReference reference="Orbit_Number_DOWNLINK" />
                  <inspectionReference reference="Relative_Orbit_Number_SENSING" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Raw" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Corrected" />
                  <inspectionReference reference="Start_Stop_Time" />
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_1a_granule_metadata">
               <name>pdi_level_1a_granule_metadata</name>
               <checklist id="pdi_level_1a_granule_metadata_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_1a_granule_metadata concluding checklist</name>
                  <inspectionReference reference="Corrupted_ISP" />
                  <inspectionReference reference="Sensing_Time" />
                  <inspectionReference reference="Missing_Lines" />
                  <inspectionReference reference="Granule_Footprint" />
                  <inspectionReference reference="Solar_Angle_Azimuth" />
                  <inspectionReference reference="Solar_Angle_Zenith" />
                  <inspectionReference reference="Incidence_Angle_Azimuth" />
                  <inspectionReference reference="Incidence_Angle_Zenith" />
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_1a_datastrip_metadata">
               <name>pdi_level_1a_datastrip_metadata</name>
               <checklist id="pdi_level_1a_datastrip_metadata_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_1a_datastrip_metadata concluding checklist</name>
                  <inspectionReference reference="Degraded_SAD" />
                  <inspectionReference reference="Lost_Packets" />
                  <inspectionReference reference="Degraded_Packets" />
                  <inspectionReference reference="Datation_Model_RMOY" />
                  <inspectionReference reference="Datation_Model_GPS_SYNC" />
                  <inspectionReference reference="Orbit_Number_DOWNLINK" />
                  <inspectionReference reference="Relative_Orbit_Number_SENSING" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Raw" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Corrected" />
                  <inspectionReference reference="Start_Stop_Time" />
                  <inspectionReference reference="Processor_Version" />
                  <inspectionReference reference="Ephemeris_Quality" />
                  <inspectionReference reference="Planimetric_Stability" />
                  <inspectionReference reference="Absolute_Location_Value" />
                  <inspectionReference reference="List_Fake_Decompressed_Source_Frames" />
                  <inspectionReference reference="EqualizationFlag" />
               </checklist>
            </item>
            <item id="http://www.esa.int/s2#pdi_level_1b_granule_metadata">
               <name>pdi_level_1b_granule_metadata</name>
               <checklist id="pdi_level_1b_granule_metadata_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_1b_granule_metadata concluding checklist</name>
                  <inspectionReference reference="Corrupted_ISP" />
                  <inspectionReference reference="Sensing_Time" />
                  <inspectionReference reference="Missing_Lines" />
                  <inspectionReference reference="Granule_Footprint" />
                  <inspectionReference reference="Solar_Angle_Azimuth" />
                  <inspectionReference reference="Solar_Angle_Zenith" />
                  <inspectionReference reference="Incidence_Angle_Azimuth" />
                  <inspectionReference reference="Incidence_Angle_Zenith" />
               </checklist>
<!--               <checklist id="pdi_level_1b_granule_metadata_basilar_checklist"
                  category="basilar">
                  <name>pdi_level_1b_granule_metadata basilar checklist</name> 
                  <inspectionReference reference="SNR" /> 
               </checklist>
-->            </item>
            <item id="http://www.esa.int/s2#pdi_level_1b_datastrip_metadata">
               <name>pdi_level_1b_datastrip_metadata</name>
               <checklist id="pdi_level_1b_datastrip_metadata_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_1b_datastrip_metadata concluding checklist</name>
                  <inspectionReference reference="Degraded_SAD" />
                  <inspectionReference reference="Lost_Packets" />
                  <inspectionReference reference="Degraded_Packets" />
                  <inspectionReference reference="Datation_Model_RMOY" />
                  <inspectionReference reference="Datation_Model_GPS_SYNC" />
                  <inspectionReference reference="Orbit_Number_DOWNLINK" />
                  <inspectionReference reference="Relative_Orbit_Number_SENSING" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Raw" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Corrected" />
                  <inspectionReference reference="Start_Stop_Time" />
                  <inspectionReference reference="Processor_Version" />
                  <inspectionReference reference="Ephemeris_Quality" />
                  <inspectionReference reference="Planimetric_Stability" />
                  <inspectionReference reference="Absolute_Location_Value" />
                  <inspectionReference reference="List_Fake_Decompressed_Source_Frames" />
                  <inspectionReference reference="Radiometric_Quality_Indicators_Absolute" />
                  <inspectionReference reference="Radiometric_Quality_Indicators_Cross_Band" />
                  <inspectionReference reference="Radiometric_Quality_Indicators_Multi_Temporal" />
                  <inspectionReference reference="EqualizationOffset" />
                  <inspectionReference reference="EqualizationFlag" />
               </checklist>
            </item>

            <item id="http://www.esa.int/s2#pdi_level_1c_tile_metadata">
               <name>pdi_level_1c_tile_metadata</name>
               <checklist id="pdi_level_1c_tile_metadata_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_1c_tile_metadata concluding checklist</name>
                  <inspectionReference reference="Corrupted_ISP" />
                  <inspectionReference reference="Sensing_Time" />
                  <inspectionReference reference="Missing_Lines" />
                  <inspectionReference reference="Solar_Angle_Azimuth" />
                  <inspectionReference reference="Solar_Angle_Zenith" />
                  <inspectionReference reference="Tile_Position_Geoposition" />
                  <inspectionReference reference="Tile_Position_Size" />
               </checklist>
<!--               <checklist id="pdi_level_1c_tile_metadata_basilar_checklist"
                  category="basilar">
                  <name>pdi_level_1c_tile_metadata basilar checklist</name>
                  <inspectionReference reference="SNR" /> 
               </checklist>
-->            </item>
            <item id="http://www.esa.int/s2#pdi_level_1c_datastrip_metadata">
               <name>pdi_level_1c_datastrip_metadata</name>
               <checklist id="pdi_level_1c_datastrip_metadata_concluding_checklist" category="concluding">
                  <name>pdi_level_1c_datastrip_metadata concluding checklist</name>
                  <inspectionReference reference="Degraded_SAD" />
                  <inspectionReference reference="Lost_Packets" />
                  <inspectionReference reference="Degraded_Packets" />
                  <inspectionReference reference="Datation_Model_RMOY" />
                  <inspectionReference reference="Datation_Model_GPS_SYNC" />
                  <inspectionReference reference="Orbit_Number_DOWNLINK" />
                  <inspectionReference reference="Relative_Orbit_Number_SENSING" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Raw" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Corrected" />
                  <inspectionReference reference="Start_Stop_Time" />
                  <inspectionReference reference="Processor_Version" />
                  <inspectionReference reference="Ephemeris_Quality" />
                  <inspectionReference reference="Planimetric_Stability" />
                  <inspectionReference reference="Absolute_Location_Value" />
                  <inspectionReference reference="List_Fake_Decompressed_Source_Frames" />
                  <inspectionReference reference="Radiometric_Quality_Indicators_Absolute" />
                  <inspectionReference reference="Radiometric_Quality_Indicators_Cross_Band" />
                  <inspectionReference reference="Radiometric_Quality_Indicators_Multi_Temporal" />
                  <inspectionReference reference="QuantificationValue" />
                  <inspectionReference reference="IntegrationTime" />
                  <inspectionReference reference="SolarRadiance" />						
                  <inspectionReference reference="EqualizationFlag" />
               </checklist>
            </item>

            <item id="http://www.esa.int/s2#pdi_level_2a_tile_metadata">
               <name>pdi_level_2a_tile_metadata</name>
               <checklist id="pdi_level_2a_tile_metadata_concluding_checklist"
                  category="concluding">
                  <name>pdi_level_2a_tile_metadata concluding checklist</name>
                  <inspectionReference reference="Sensing_Time" />
                  <inspectionReference reference="Solar_Angle_Azimuth" />
                  <inspectionReference reference="Solar_Angle_Zenith" />
                  <inspectionReference reference="Tile_Position_Geoposition" />
                  <inspectionReference reference="Tile_Position_Size" />
                  <inspectionReference reference="schemaXmlValidator" />
               </checklist>
            </item>


            <item id="http://www.esa.int/s2#pdi_level_2a_datastrip_metadata">
               <name>pdi_level_2a_datastrip_metadata</name>
               <checklist id="pdi_level_2a_datastrip_metadata_concluding_checklist" category="concluding">
                  <name>pdi_level_2a_datastrip_metadata concluding checklist</name>
                  <inspectionReference reference="Degraded_SAD" />
                  <inspectionReference reference="Lost_Packets" />
                  <inspectionReference reference="Degraded_Packets" />
                  <inspectionReference reference="Datation_Model_RMOY" />
                  <inspectionReference reference="Datation_Model_GPS_SYNC" />
                  <inspectionReference reference="Orbit_Number_DOWNLINK" />
                  <inspectionReference reference="Relative_Orbit_Number_SENSING" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Raw" />
                  <inspectionReference reference="Attitude_Quality_Indicator_Corrected" />
                  <inspectionReference reference="Start_Stop_Time" />
                  <!--inspectionReference reference="Processor_Version" /-->
                  <inspectionReference reference="Ephemeris_Quality" />
                  <inspectionReference reference="Planimetric_Stability" />
                  <inspectionReference reference="Absolute_Location_Value" />
                  <!--inspectionReference reference="List_Fake_Decompressed_Source_Frames" /-->
                  <inspectionReference reference="Radiometric_Quality_Indicators_Absolute" />
                  <inspectionReference reference="Radiometric_Quality_Indicators_Cross_Band" />
                  <inspectionReference reference="Radiometric_Quality_Indicators_Multi_Temporal" />
                  <inspectionReference reference="QuantificationValueBOA" />
                  <inspectionReference reference="QuantificationValueAOT" />
                  <inspectionReference reference="QuantificationValueWVP" />
		  <inspectionReference reference="IntegrationTime" />
                  <inspectionReference reference="EqualizationFlag" />
                  <inspectionReference reference="schemaXmlValidator" />

               </checklist>
            </item>

            <!--
            <item id="http://www.gael.fr/drb#safe-product">
               <name>safe-product</name>
               <checklist id="safe-product_concluding_checklist"
                  category="concluding">
                  <name>safe-product concluding checklist</name>
                  <inspectionReference reference="acquisitionPeriodExists" />
                  <inspectionReference reference="processingExists" />
                  <inspectionReference reference="acquisitionPeriodCategory" />
                  <inspectionReference reference="acquisitionPeriodClassification" />
                  <inspectionReference reference="processingCategory" />
                  <inspectionReference reference="processingClassification" />
                  <inspectionReference reference="platformCategory" />
                  <inspectionReference reference="platformClassification" />
                  <inspectionReference reference="schemaCategory" />
                  <inspectionReference reference="schemaClassification" />
                  <inspectionReference reference="annotationCategory" />
                  <inspectionReference reference="annotationClassification" />
                  <inspectionReference reference="frameSetCategory" />
                  <inspectionReference reference="frameSetClassification" />
                  <inspectionReference reference="gridReferenceCategory" />
                  <inspectionReference reference="gridReferenceClassification" />
                  <inspectionReference reference="indexCategory" />
                  <inspectionReference reference="indexClassification" />
                  <inspectionReference reference="informationCategory" />
                  <inspectionReference reference="informationClassification" />
                  <inspectionReference reference="orbitReferenceCategory" />
                  <inspectionReference reference="orbitReferenceClassification" />
                  <inspectionReference reference="qualityInformationCategory" />
                  <inspectionReference reference="qualityInformationClassification" />
                  <inspectionReference reference="idReferences" />
                  <inspectionReference reference="extraData" />
                  <inspectionReference reference="hrefExist" />
               </checklist>
            </item>
            -->
         </items>
         <inspections>
	 
            <xqueryInspection version="1.0" id="SolarRadiance">
               <name>Check Solar Radiance</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="band_thresholds_min">1912.69, 1970.06, 1820.66, 1505.24, 1409.25, 1286.33, 1153.82, 1036.14, 956.96, 806.84, 367.51, 246.07, 86.86</parameter>
                  <parameter name="band_thresholds_max">1916.52, 1974.00, 1824.30, 1508.25, 1412.07, 1288.90, 1156.13, 1038.21, 958.88, 808.46, 368.25, 246.56, 87.03</parameter>
               </queryParameters>
               <query><![CDATA[
						declare variable $band_thresholds_min as xs:sequence* external;
						declare variable $band_thresholds_max as xs:sequence* external;						
						let $flag:=(
							for $band_number in (0 to 12)		
							let $solar_radiance := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/Reflectance_Conversion/Solar_Irradiance_List/SOLAR_IRRADIANCE[@bandId=$band_number]
							where $solar_radiance < $band_thresholds_min[position() = $band_number+1] or $solar_radiance > $band_thresholds_max[position() = $band_number+1] 
							return '1'
						)
						return 
                  if (fn:empty ($flag)) then
                     true()
                  else
                     false()

               ]]></query>
               <successMessage><![CDATA[
             	   "SOLAR RADIANCE is OK"
               ]]></successMessage>
               <failureMessage><![CDATA[
						declare variable $band_thresholds_min as xs:sequence* external;
						declare variable $band_thresholds_max as xs:sequence* external;						
						let $d:=(
							for $band_number in (0 to 12)		
							let $solar_radiance := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/Reflectance_Conversion/Solar_Irradiance_List/SOLAR_IRRADIANCE[@bandId=$band_number]
							where $solar_radiance < $band_thresholds_min[position() = $band_number+1] or $solar_radiance > $band_thresholds_max[position() = $band_number+1]
							return  concat ("@SOLAR_RADIANCE_IN_BAND_",$band_number,"@",$solar_radiance," Allowed range [",$band_thresholds_min[position() = $band_number+1],",",$band_thresholds_max[position() = $band_number+1],"]@")
						)
						return  concat ("SOLAR RADIANCE is NOT OK", string-join($d,''))
 
               ]]></failureMessage>
            </xqueryInspection>
				

            <xqueryInspection version="1.0" id="EqualizationFlag">
               <name>Check EQUALIZATION_MODE</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">true</parameter>
               </queryParameters>
               <query><![CDATA[	       
             	   let $equ_mode:= *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Sensor_Configuration/Acquisition_Configuration/EQUALIZATION_MODE               
		   return ($equ_mode='true')
               ]]></query>
               <successMessage><![CDATA[
	       
		"Equalization Mode is set to TRUE"
               
               ]]></successMessage>
               <failureMessage><![CDATA[
	       
		"Equalization Mode is set to FALSE"

               ]]></failureMessage>
            </xqueryInspection>	 
	    
	    	 
            <xqueryInspection version="1.0" id="EqualizationOffset">
               <name>Check OFFSET_PROC</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">10000</parameter>
               </queryParameters>
               <query><![CDATA[
	       
             	   declare variable $band_thresholds as xs:sequence* external;
		   			let $flag:=(
                   	let $offsets := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/Equalization/Equalized_Band_List/Equalized_Band/OFFSET_PROC
                   	return
		   				for $offset in $offsets
		   				where $offset != 'true'
		   				return 1
						)
		   			return 
                  if (fn:empty ($flag)) then
                     true()
                  else
                     false()
                  
               ]]></query>
               <successMessage><![CDATA[
	       
 	              "Equalization band OFFSETS flags are set to TRUE"
               
               ]]></successMessage>
               <failureMessage><![CDATA[
	       
             	   declare variable $band_thresholds as xs:sequence* external;
             	   let $d:=(
		   	for $band_number in (0 to 12)		
                   	let $offset := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/Equalization/Equalized_Band_List/Equalized_Band[@bandId=$band_number]/OFFSET_PROC
			where $offset != 'true' 
                   	return  concat ("@OFFSET_PROC_IN_BAND_",$band_number,"@",$offset,"@")
		   )
		   return  concat ("Equalization band OFFSETS are NOT OK", string-join($d,''))

               ]]></failureMessage>
            </xqueryInspection>
	 

            <xqueryInspection version="1.0" id="IntegrationTime">
               <name>Check INTEGRATION_TIME</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="band_thresholds">6.5712035, 1.3697743, 1.0777116, 1.4165044, 2.7489364, 2.9748678, 3.0224323, 1.4982820, 3.0105412, 9.3092918, 5.4448843, 1.4398694, 1.5003681</parameter>
                  <parameter name="band_thresholds_abs">6.5712035, 1.3697743, 1.0777116, 1.4165044, 2.7489364, 2.9748678, 3.0224323, 1.4982820, 3.0105412, 9.3092918, 2.0690560, 1.4398694, 1.5003681</parameter>
               </queryParameters>
               <query><![CDATA[
             	   declare variable $band_thresholds as xs:sequence* external;
             	   declare variable $band_thresholds_abs as xs:sequence* external;						
						let $flag:=(
							if (*[matches(name(), ".*_DataStrip_ID")]/General_Info/Datatake_Info/DATATAKE_TYPE = 'INS-ABSR') then							
								for $band_number in (0 to 12)		
                   			let $integration_time := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Sensor_Configuration/Acquisition_Configuration/Spectral_Band_Info/Spectral_Band_Information[@bandId=$band_number]/INTEGRATION_TIME
		   						where $integration_time < $band_thresholds_abs[position() = $band_number+1] * 0.99 or $integration_time > $band_thresholds_abs[position() = $band_number+1] * 1.01
		   					return '1'							
							else
								for $band_number in (0 to 12)		
                   			let $integration_time := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Sensor_Configuration/Acquisition_Configuration/Spectral_Band_Info/Spectral_Band_Information[@bandId=$band_number]/INTEGRATION_TIME
		   						where $integration_time < $band_thresholds[position() = $band_number+1] * 0.99 or $integration_time > $band_thresholds[position() = $band_number+1] * 1.01
		   					return '1'
						)
						return 
                  if (fn:empty ($flag)) then
                     true()
                  else
                     false()

               ]]></query>
               <successMessage><![CDATA[
             	   "INTEGRATION_TIME is OK"
               ]]></successMessage>
               <failureMessage><![CDATA[
             	   declare variable $band_thresholds as xs:sequence* external;
             	   declare variable $band_thresholds_abs as xs:sequence* external;						
             	   let $d:=(
							if (*[matches(name(), ".*_DataStrip_ID")]/General_Info/Datatake_Info/DATATAKE_TYPE = 'INS-ABSR') then							
		   					for $band_number in (0 to 12)		
                   			let $integration_time := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Sensor_Configuration/Acquisition_Configuration/Spectral_Band_Info/Spectral_Band_Information[@bandId=$band_number]/INTEGRATION_TIME
									where $integration_time < $band_thresholds_abs[position() = $band_number+1] * 0.99 or $integration_time > $band_thresholds_abs[position() = $band_number+1] * 1.01 
                   		return  concat ("@INTEGRATION_TIME_IN_BAND_",$band_number,"@",$integration_time," Allowed range [",$band_thresholds_abs[position() = $band_number+1 ] * 0.99,",",$band_thresholds_abs[position() = $band_number+1 ] * 1.01,"]@")
							else
		   					for $band_number in (0 to 12)		
                   			let $integration_time := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Sensor_Configuration/Acquisition_Configuration/Spectral_Band_Info/Spectral_Band_Information[@bandId=$band_number]/INTEGRATION_TIME
									where $integration_time < $band_thresholds[position() = $band_number+1] * 0.99 or $integration_time > $band_thresholds[position() = $band_number+1] * 1.01 
                   		return  concat ("@INTEGRATION_TIME_IN_BAND_",$band_number,"@",$integration_time," Allowed range [",$band_thresholds[position() = $band_number+1 ] * 0.99,",",$band_thresholds[position() = $band_number+1 ] * 1.01,"]@")
		   			)
						return  concat ("INTEGRATION_TIME is NOT OK", string-join($d,''))
 
               ]]></failureMessage>
            </xqueryInspection>
	    
            <xqueryInspection version="1.0" id="QuantificationValue">
               <name>Check QUANTIFICATION_VALUE</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">10000</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold as xs:positiveInteger* external;
                   let $quantification_value := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/QUANTIFICATION_VALUE
                   return
                   xs:positiveInteger(data($quantification_value)) = $threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                "QUANTIFICATION_VALUE is OK"
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                   declare variable $threshold as xs:positiveInteger* external;
                   let $quantification_value := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info//Radiometric_Info/QUANTIFICATION_VALUE
                   return 
                concat("QUANTIFICATION_VALUE is not ok (",$quantification_value,
                       ") and does not match the fixed value of ",$threshold,
                       "@QUANTIFICATION_VALUE@", $quantification_value, "@")
               
               ]]></failureMessage>
            </xqueryInspection>

            <xqueryInspection version="1.0" id="QuantificationValueBOA">
               <name>Check BOA QUANTIFICATION_VALUE</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">10000</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold as xs:double* external;
                   let $quantification_value := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/QUANTIFICATION_VALUES_LIST/BOA_QUANTIFICATION_VALUE
                   return
                   xs:double(data($quantification_value)) = $threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                "BOA QUANTIFICATION_VALUE is OK"
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                   declare variable $threshold as xs:double* external;
                   let $quantification_value := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/QUANTIFICATION_VALUES_LIST/BOA_QUANTIFICATION_VALUE
                   return 
                concat("BOA QUANTIFICATION_VALUE is not ok (",$quantification_value,
                       ") and does not match the fixed value of ",$threshold,
                       "@BOA_QUANTIFICATION_VALUE@", $quantification_value, "@")
               
               ]]></failureMessage>
            </xqueryInspection>

            <xqueryInspection version="1.0" id="QuantificationValueAOT">
               <name>Check AOT QUANTIFICATION_VALUE</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">1000</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold as xs:double* external;
                   let $quantification_value := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/QUANTIFICATION_VALUES_LIST/AOT_QUANTIFICATION_VALUE
                   return
                   xs:double(data($quantification_value)) = $threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                "AOT QUANTIFICATION_VALUE is OK"
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                   declare variable $threshold as xs:double* external;
                   let $quantification_value := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/QUANTIFICATION_VALUES_LIST/AOT_QUANTIFICATION_VALUE
                   return 
                concat("AOT QUANTIFICATION_VALUE is not ok (",$quantification_value,
                       ") and does not match the fixed value of ",$threshold,
                       "@AOT_QUANTIFICATION_VALUE@", $quantification_value, "@")
               
               ]]></failureMessage>
            </xqueryInspection>

            <xqueryInspection version="1.0" id="QuantificationValueWVP">
               <name>Check WVP QUANTIFICATION_VALUE</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">1000</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold as xs:double* external;
                   let $quantification_value := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/QUANTIFICATION_VALUES_LIST/WVP_QUANTIFICATION_VALUE
                   return
                   xs:double(data($quantification_value)) = $threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                "WVP QUANTIFICATION_VALUE is OK"
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                   declare variable $threshold as xs:double* external;
                   let $quantification_value := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Radiometric_Info/QUANTIFICATION_VALUES_LIST/WVP_QUANTIFICATION_VALUE
                   return 
                concat("WVP QUANTIFICATION_VALUE is not ok (",$quantification_value,
                       ") and does not match the fixed value of ",$threshold,
                       "@WVP_QUANTIFICATION_VALUE@", $quantification_value, "@")
               
               ]]></failureMessage>
            </xqueryInspection>

            <xqueryInspection version="1.0" id="checkL1CMasks">
               <name>Masks availability check.</name>
               <thematics>
                  <thematic>FORMAT_CORRECTNESS</thematic>
               </thematics>
               <query><![CDATA[
                     let $classi := QI_DATA/*[matches (name(), ".*MSK_CLASSI.*_B00.*\.jp2")]
                     let $qualit := QI_DATA/*[matches (name(), ".*MSK_QUALIT.*_B.*\.jp2")]
                     let $detfoo := QI_DATA/*[matches (name(), ".*MSK_DETFOO.*_B.*\.jp2")]
                     return
                     if (fn:count($classi) != 1
                         or fn:count($qualit) != 13
                         or fn:count($detfoo) != 13
                     )
                     then
                        fn:false()
                     else
                        fn:true()                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "All elements in QI_DATA are present."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                     let $classi := QI_DATA/*[matches (name(), ".*MSK_CLASSI.*_B00.*\.jp2")]
                     let $qualit := QI_DATA/*[matches (name(), ".*MSK_QUALIT.*_B.*\.jp2")]
                     let $detfoo := QI_DATA/*[matches (name(), ".*MSK_DETFOO.*_B.*\.jp2")]
                     return concat("Some elements are missing in QI_DATA", 
                        (if (fn:count($classi) != 1) then ", MSK_CLASSI" else ""),
                        (if (fn:count($qualit) != 13) then ", MSK_QUALIT" else ""),
                        (if (fn:count($detfoo) != 13) then ", MSK_DETFOO" else "")
                     )
               ]]></failureMessage>
            </xqueryInspection>

            <customJavaInspection
               class="fr.gael.olqc.inspection.impl.band_stats.BandStatsInspector" 
               classpath="band_stats/amalfi-config-sentinel-2-band-stats-inspector-15.0.0.jar"
               version="1.0" id="QualitMaskNbBands" inspectorId="http://www.esa.int/s2#OlqcBandStatsInspector">
               <name>Checks number of bands in quality masks</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <parameters>
                  <masks xmlns=".hack//Sign">
                     <mask>
                        <typeName>
                           QI_DATA/MSK_QUALIT:NB_BANDS=8
                        </typeName>
                     </mask>
                  </masks>
               </parameters>
            </customJavaInspection>

            <customJavaInspection
               class="fr.gael.olqc.inspection.impl.band_stats.BandStatsInspector" 
               classpath="band_stats/amalfi-config-sentinel-2-band-stats-inspector-15.0.0.jar"
               version="1.0" id="ClassiMaskNbBands" inspectorId="http://www.esa.int/s2#OlqcBandStatsInspector">
               <name>Checks number of bands in classification masks</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <parameters>
                  <masks xmlns="_">
                     <mask>
                        <typeName>
                           QI_DATA/MSK_CLASSI:NB_BANDS=3
                        </typeName>
                     </mask>
                  </masks>
               </parameters>
            </customJavaInspection>

            <customJavaInspection
               class="fr.gael.olqc.inspection.impl.band_stats.BandStatsInspector" 
               classpath="band_stats/amalfi-config-sentinel-2-band-stats-inspector-15.0.0.jar"
               version="1.0" id="DetfooMaskNbBands" inspectorId="http://www.esa.int/s2#OlqcBandStatsInspector">
               <name>Checks number of bands in detector footprint masks</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <parameters>
                  <masks xmlns="_">
                     <mask>
                        <typeName>
                           QI_DATA/MSK_DETFOO:NB_BANDS
                        </typeName>
                     </mask>
                  </masks>
               </parameters>
            </customJavaInspection>

            <customJavaInspection
               class="fr.gael.olqc.inspection.impl.band_stats.BandStatsInspector" 
               classpath="band_stats/amalfi-config-sentinel-2-band-stats-inspector-15.0.0.jar"
               version="1.0" id="DetfooMaskFormat" inspectorId="http://www.esa.int/s2#OlqcBandStatsInspector">
               <name>Check DETFOO for format correctness</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <parameters>
                  <masks xmlns="check if bands are empty">
                     <mask>
                        <typeName>
                           QI_DATA/MSK_DETFOO:PERCENTAGE
                        </typeName>
                     </mask>
                  </masks>
               </parameters>
            </customJavaInspection>

            <customJavaInspection
               class="fr.gael.olqc.inspection.impl.band_stats.BandStatsInspector" 
               classpath="band_stats/amalfi-config-sentinel-2-band-stats-inspector-15.0.0.jar"
               version="1.0" id="Data_Loss" inspectorId="http://www.esa.int/s2#OlqcBandStatsInspector">
               <name>Check TECQUA for data loss</name>
               <thematic>GENERAL_QUALITY</thematic>
               <parameters>
                  <masks xmlns="record non-zero percentages of band number 2 (MSI LOST)">
                     <mask>
                        <typeName>
                           QI_DATA/MSK_QUALIT:PERCENTAGE?2
                        </typeName>
                     </mask>
                  </masks>
               </parameters>
            </customJavaInspection>

            <xqueryInspection version="1.0" id="Lost_Packets">
               <name>Check the number of lost packets</name>
               <thematic>GENERAL_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">0</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold as xs:positiveInteger* external;
                   let $lost_packets := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Sensor_Configuration/Source_Packet_Description/Degradation_Summary/NUMBER_OF_LOST_PACKETS
                   return
                   if (fn:empty ($lost_packets))
                   then
                      fn:true()
                   else
                      xs:double(data($lost_packets)) <= xs:double($threshold)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  declare variable $threshold as xs:positiveInteger* external;
                  let $lost_packets := *[matches(name(), ".*_DataStrip_ID")]/
                     Image_Data_Info/Sensor_Configuration/Source_Packet_Description/Degradation_Summary/NUMBER_OF_LOST_PACKETS
                  return
                  if (fn:empty ($lost_packets))
                  then
                     "NUMBER_OF_LOST_PACKETS not found in dataset"
                  else
                     concat ("NUMBER_OF_LOST_PACKETS value ", data($lost_packets), " does not exceed the threshold (", $threshold ,") ",
                        "@NUMBER_OF_LOST_PACKETS@", data($lost_packets), "@" )
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  declare variable $threshold as xs:positiveInteger* external;
                  let $lost_packets := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Sensor_Configuration/Source_Packet_Description/Degradation_Summary/NUMBER_OF_LOST_PACKETS
                  let $bands_with_lost_packets := (
                     for $b in (0 to 12)
                        let $biggest := max(*[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Sensor_Configuration/Source_Packet_Description/Source_Packet_Counters_List/Detector_List/Detector/Band_List/Band[@bandId=$b]/NB_OF_SOURCE_PACKETS )
                        let $band_number := (
                           if ($b < 8) then $b+1
                           else if ($b > 8) then $b
                           else concat($b,"A")
                        )
                        let $band := (
                           for $d in (1 to 12) 
                              let $det := *[matches(name(), ".*_DataStrip_ID")]/Image_Data_Info/Sensor_Configuration/Source_Packet_Description/Source_Packet_Counters_List/Detector_List/Detector[$d]/Band_List/Band[@bandId=$b]/NB_OF_SOURCE_PACKETS
                           where $det != $biggest
                           return concat("Detector_",$d, ": ", xs:integer($biggest) - $det,". ")			
                        )
                     where not(empty($band))
                     return
                        concat("@NUMBER_OF_LOST_SOURCE_PACKETS_IN_BAND_",$band_number,"@", string-join($band, ''), "@")
                  )
                  return
                     concat ("NUMBER_OF_LOST_PACKETS value ", data($lost_packets), " exceeds the threshold (", $threshold ,") ",
                        "@NUMBER_OF_LOST_PACKETS@", data($lost_packets), "@",
                        string-join($bands_with_lost_packets,''),
                        "@coment@The Bands criteria expressed in this section is B1-B12 + B8A@" )
               
               ]]></failureMessage>
            </xqueryInspection>



            <xqueryInspection version="1.0" id="checkSafeManifest">
               <name>Safe Manifest check.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     let $manifest := *[name()="manifest.safe"]
                     return
                     if (fn:empty ($manifest))
                     then
                        fn:false()
                     else
                        if (fn:data($manifest/@size)=0)
                        then
                           fn:false()
                        else   
                           if (fn:empty ($manifest/XFDU/*))
                           then
                              fn:false()
                           else
                              fn:true()
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "Safe manifest present."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                  "Safe manifest not present or empty."
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="checkInventory">
               <name>Inventory metadata file check.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     let $metadata := *[name()="Inventory_Metadata.xml"]
                     return
                     if (fn:empty ($metadata))
                     then
                        fn:false()
                     else
                        if (fn:data($metadata/@size)=0)
                        then
                           fn:false()
                        else   
                           if (fn:empty ($metadata/Inventory_Metadata/*))
                           then
                              fn:false()
                           else
                              fn:true()
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "Inventory metadata file is present."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                  "Inventory metadata file is not present or empty."
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="checkMetadata">
               <name>Metadata file check.</name>
               <thematics>
                  <thematic>FORMAT_CORRECTNESS</thematic>
                  <thematic>SENSOR_QUALITY</thematic>
                  <thematic>GENERAL_QUALITY</thematic>
               </thematics>
               <query><![CDATA[
                  
                     let $metadata := *[matches (name(), "(S2._...._MTD_.*|MTD_..)\.xml")]
                     return
                     if (fn:empty ($metadata))
                     then
                        fn:false()
                     else
                        if (fn:data($metadata/@size)=0)
                        then
                           fn:false()
                        else   
                           if (fn:empty ($metadata/*[matches(name(), "(DIMAP_|)Level.*")]/*))
                           then
                              fn:false()
                           else
                              fn:true()
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "Metadata file is present."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                  "Metadata file is not present or empty."
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="checkL2AImages">
               <name>L2A images availability check.</name>
               <thematics>
                  <thematic>FORMAT_CORRECTNESS</thematic>
               </thematics>
               <query><![CDATA[
                  
                     let $tileB01 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B01.*\.jp2")]
                     let $tileB02 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B02.*\.jp2")]
                     let $tileB03 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B03.*\.jp2")]
                     let $tileB04 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B04.*\.jp2")]
                     let $tileB05 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B05.*\.jp2")]
                     let $tileB06 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B06.*\.jp2")]
                     let $tileB07 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B07.*\.jp2")]
                     let $tileB08 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B08.*\.jp2")]
                     let $tileB8A := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B8A.*\.jp2")]
                     let $tileB09 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B09.*\.jp2")]
                     let $tileB10 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B10.*\.jp2")]
                     let $tileB11 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B11.*\.jp2")]
                     let $tileB12 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B12.*\.jp2")]
                     let $tileAOT := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*AOT.*\.jp2")]
                     let $tileWVP := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*WVP.*\.jp2")]
                     let $tileSCL := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*SCL.*\.jp2")]
                     let $tileTCI := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*TCI.*\.jp2")]
                     return
                     if (fn:empty ($tileB01)
                         or fn:empty ($tileB02)
                         or fn:empty ($tileB03)
                         or fn:empty ($tileB04)
                         or fn:empty ($tileB05)
                         or fn:empty ($tileB06)
                         or fn:empty ($tileB07)
                         or fn:empty ($tileB08)
                         or fn:empty ($tileB8A)
                         or fn:empty ($tileB09)
                         (: or fn:empty ($tileB10)   B10 is not expected to be available in L2A products :)
                         or fn:empty ($tileB11)
                         or fn:empty ($tileB12)
                         or fn:empty ($tileAOT)
                         or fn:empty ($tileWVP)
                         or fn:empty ($tileSCL)
                         or fn:empty ($tileTCI)
                     )
                     then
                        fn:false()
                     else
                        fn:true()                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "All bands are present."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                     let $tileB01 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B01.*\.jp2")]
                     let $tileB02 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B02.*\.jp2")]
                     let $tileB03 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B03.*\.jp2")]
                     let $tileB04 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B04.*\.jp2")]
                     let $tileB05 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B05.*\.jp2")]
                     let $tileB06 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B06.*\.jp2")]
                     let $tileB07 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B07.*\.jp2")]
                     let $tileB08 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B08.*\.jp2")]
                     let $tileB8A := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B8A.*\.jp2")]
                     let $tileB09 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B09.*\.jp2")]
                     let $tileB10 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B10.*\.jp2")]
                     let $tileB11 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B11.*\.jp2")]
                     let $tileB12 := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*B12.*\.jp2")]
                     let $tileAOT := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*AOT.*\.jp2")]
                     let $tileWVP := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*WVP.*\.jp2")]
                     let $tileSCL := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*SCL.*\.jp2")]
                     let $tileTCI := IMG_DATA/*[matches (name(), "R..m")]/*[matches (name(), ".*TCI.*\.jp2")]
                     return concat("Some bands are missing", 
                        (if (fn:empty ($tileB01)) then ", B01" else ""),
                        (if (fn:empty ($tileB02)) then ", B02" else ""),
                        (if (fn:empty ($tileB03)) then ", B03" else ""),
                        (if (fn:empty ($tileB04)) then ", B04" else ""),
                        (if (fn:empty ($tileB05)) then ", B05" else ""),
                        (if (fn:empty ($tileB06)) then ", B06" else ""),
                        (if (fn:empty ($tileB07)) then ", B07" else ""),
                        (if (fn:empty ($tileB08)) then ", B08" else ""),
                        (if (fn:empty ($tileB8A)) then ", B8A" else ""),
                        (if (fn:empty ($tileB09)) then ", B09" else ""),
                        (: (if (fn:empty ($tileB10)) then ", B10" else ""),  B10 is not expected to be available in L2A products :)
                        (if (fn:empty ($tileB11)) then ", B11" else ""),
                        (if (fn:empty ($tileB12)) then ", B12" else ""),
                        (if (fn:empty ($tileAOT)) then ", AOT" else ""),
                        (if (fn:empty ($tileWVP)) then ", WVP" else ""),
                        (if (fn:empty ($tileSCL)) then ", SCL" else ""),
                        (if (fn:empty ($tileTCI)) then ", TCI" else "")
                     )
               ]]></failureMessage>
            </xqueryInspection>
	    

            <xqueryInspection version="1.0" id="checkL2AMasks">
               <name>L2A Masks availability check.</name>
               <thematics>
                  <thematic>FORMAT_CORRECTNESS</thematic>
               </thematics>
               <query><![CDATA[
                     let $classi := QI_DATA/*[matches (name(), ".*CLASSI.*\.jp2")]
                     let $qualit := QI_DATA/*[matches (name(), ".*QUALIT.*\.jp2")]
                     let $detfoo := QI_DATA/*[matches (name(), ".*DETFOO.*\.jp2")]
		     let $cloudp := QI_DATA/*[matches (name(), ".*CLDPRB.*\.jp2")]
                     let $snowpr := QI_DATA/*[matches (name(), ".*SNWPRB.*\.jp2")]
                     return
                     if (fn:count($classi) != 1
                         or fn:count($qualit) != 13
                         or fn:count($detfoo) != 13
                     )
                     then
                        fn:false()
                     else
                        fn:true()                 
               ]]></query>
               <successMessage><![CDATA[
               
                  "All elements in QI_DATA are present."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                     let $classi := QI_DATA/*[matches (name(), ".*MSK_CLASSI.*_B00.*\.jp2")]
                     let $qualit := QI_DATA/*[matches (name(), ".*MSK_QUALIT.*_B.*\.jp2")]
                     let $detfoo := QI_DATA/*[matches (name(), ".*MSK_DETFOO.*_B.*\.jp2")]
		     let $cloudp := QI_DATA/*[matches (name(), ".*MSK_CLDPRB_.*[2|6]0m.jp2")]
                     let $snowpr := QI_DATA/*[matches (name(), ".*MSK_SNWPRB_.*[2|6]0m.jp2")]
                     return concat("Some elements are missing in QI_DATA", 
                        (if (fn:count($classi) != 1) then ", MSK_CLASSI" else ""),
                        (if (fn:count($qualit) != 13) then ", MSK_QUALIT" else ""),
                        (if (fn:count($detfoo) != 13) then ", MSK_DETFOO" else ""),
                        (if (fn:count($cloudp) != 2) then ", MSK_CLDPRB" else ""),
                        (if (fn:count($snowpr) != 2) then ", MSK_SNWPRB" else "")						
                     )
               ]]></failureMessage>
            </xqueryInspection>
				
            <xqueryInspection version="1.0" id="testSize">
               <name>Generic file size check.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <queryParameters>
                  <parameter name="minSize">0</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                  declare variable $minSize as xs:positiveInteger* external;
                  @size>$minSize
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  declare variable $minSize as xs:positiveInteger* external;
                  concat("File size (", @size , ") is greater than ", $minSize)
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  declare variable $minSize as xs:positiveInteger* external;
                  concat("File size (", @size , ") is lower than ", $minSize)
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Corrupted_ISP">
               <name>Check the consistency of the granules.</name>
               <thematic>SENSOR_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">0</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold as xs:positiveInteger* external;
                   let $field_to_check := 
                         *[matches(name(), ".*_Granule_ID")]/
                         Quality_Indicators_Info/
                         Image_Content_QI/
                         Common_IMG_QI/
                         DEGRADED_MSI_DATA_PERCENTAGE
                   return
                   if (fn:empty ($field_to_check))
                   then
                      fn:true()
                   else
                      xs:double(data($field_to_check)) <= xs:double($threshold)
                   
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  let $sps:=
                     *[matches(name(), ".*_Granule_ID")]/
                         Quality_Indicators_Info/
                         Image_Content_QI/
                         Source_Packet_description/
                         Lost_Source_Packet
                   return
                   if (fn:count ($sps)=0)
                   then
                      "No Error detected. @CORRUPTED_ISP@0@"
                   else
                      (
                         let $num := fn:count($sps)
                         return
                         concat ("Number of degraded ISP(s)=" , $num,
                            "  @CORRUPTED_ISP@", $num, "@ ",
                            fn:string-join ((
                               for $sp in $sps
                               return
                                  fn:concat (
                                     "@DEGRADATION_TYPE(", 
                                        data($sp/@band_Id), ",",
                                        data($sp/@detector_Id), ")@", 
                                     data($sp/DEGRADATION_TYPE), "@")), ' ')
                         )
                      )
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  let $sps:=
                     *[matches(name(), ".*_Granule_ID")]/
                         Quality_Indicators_Info/
                         Image_Content_QI/
                         Source_Packet_description/
                         Lost_Source_Packet
                   return
                   if (fn:count ($sps)=0)
                   then
                      "Error detected but no corrupted list available in the product."
                   else
                      (
                         let $num := fn:count($sps)
                         return
                         concat ("Number of degraded ISP(s)=" , $num,
                            "  @CORRUPTED_ISP@", $num, "@ ",
                            fn:string-join ((
                               for $sp in $sps
                               return
                                  fn:concat (
                                     "@DEGRADATION_TYPE(", 
                                        data($sp/@band_Id), ",",
                                        data($sp/@detector_Id), ")@", 
                                     data($sp/DEGRADATION_TYPE), "@")), ' ')
                         )
                      )
               
               ]]></failureMessage>
            </xqueryInspection>


            <xqueryInspection version="1.0" id="Degraded_SAD">
               <name>Check the consistency of relative orbit.</name>
               <thematic>SENSOR_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">0</parameter>
               </queryParameters>
               <query><![CDATA[
                   declare variable $threshold as xs:positiveInteger* external;
                   let $field_to_check := *[matches(name(), ".*_DataStrip_ID")]/Quality_Indicators_Info/DEGRADED_ANC_DATA_PERCENTAGE
						 return						 
                   if (fn:empty ($field_to_check))
                   then
                      fn:false()
                   else
                      xs:double(data($field_to_check)) <= xs:double($threshold)

               ]]></query>
               <successMessage><![CDATA[
                   "No Degraded SAD"
               
               ]]></successMessage>
               <failureMessage><![CDATA[
                   declare variable $threshold as xs:positiveInteger* external;
                   let $field_to_check := *[matches(name(), ".*_DataStrip_ID")]/Quality_Indicators_Info/DEGRADED_ANC_DATA_PERCENTAGE
                   return
                   concat("SAD is degraded. @DEGRADED_SAD@", $field_to_check, "@")
               
               ]]></failureMessage>
            </xqueryInspection>
				

            <xqueryInspection version="1.0" id="Sensing_Time">
               <name>Check the consistency of the sensing time.</name>
               <thematic>SENSOR_QUALITY</thematic>
               <query><![CDATA[
                  
                   let $field_to_check := *[matches(name(), ".*_(Granule|Tile)_ID")]/
                      General_Info/SENSING_TIME
                   return
                   if (fn:empty ($field_to_check))
                   then
                      fn:false()
                   else
                      fn:true()
                   
                  
               ]]></query>
               <successMessage><![CDATA[
               
                   let $field_to_check := 
                         *[matches(name(), ".*_(Granule|Tile)_ID")]/
                         General_Info/SENSING_TIME
                   return
                   concat ("Sensing time is valid ", 
                      "@SENSING_TIME@", data($field_to_check), "@")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  "Sensing time is invalid "
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Missing_Lines">
               <name>Check the number of missing lines.</name>
               <thematic>SENSOR_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">0</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold as xs:positiveInteger* external;
                   let $fields_to_check := *[matches(name(), ".*_Granule_ID")]/
                         Quality_Indicators_Info/
                         Image_Content_QI/
                         Source_Packet_description/
                         Lost_Source_Packet
                   return
                   if (fn:count ($fields_to_check)=0)
                   then
                      fn:true()
                   else
                   (
                      let $missings := 
                      (
                         for $field_to_check in $fields_to_check
                         let $missing_line_num := xs:integer(data ($field_to_check/NUMBER_OF_SP_ERROR))*16
                         where xs:integer($missing_line_num) >= xs:integer($threshold)
                         return
                            $missing_line_num
                      )
                      return 
                         fn:count($missings)=0
                   )
                  
               ]]></query>
               <successMessage><![CDATA[
               
                   declare variable $threshold as xs:positiveInteger* external;
                   let $fields_to_check := *[matches(name(), ".*_Granule_ID")]/
                      Quality_Indicators_Info/
                      Image_Content_QI/
                      Source_Packet_description/
                      Lost_Source_Packet
                   return
                   if (fn:count ($fields_to_check)=0)
                   then
                      "No missing lines @MISSING_LINES@0@"
                   else
                   (
                      let $missings := 
                      (
                         for $field_to_check in $fields_to_check
                         let $missing_line_num:=xs:integer(data ($field_to_check/NUMBER_OF_SP_ERROR))*16
                         let $degradation_type:=data ($field_to_check/DEGRADATION_TYPE)
                         return
                            concat (
                               "@MISSING_LINES(", 
                                  data($field_to_check/@band_Id), ",",
                                  data($field_to_check/@detector_Id), ")@", $missing_line_num, "@ ",
                               "@DEGRADATION_TYPE(", 
                                  data($field_to_check/@band_Id), ",",
                                  data($field_to_check/@detector_Id), ")@",$degradation_type , "@")
                      )
                      return 
                         if (fn:empty($missings))
                         then
                            "No missing lines @MISSING_LINES@0@"
                         else
                            concat (
                               "Number of missing lines does not exceeds the threshold (",
                                $threshold, ") ", string-join($missings, ' '))
                   )
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  declare variable $threshold as xs:positiveInteger* external;
                   let $fields_to_check := *[matches(name(), ".*_Granule_ID")]/
                      Quality_Indicators_Info/
                      Image_Content_QI/
                      Source_Packet_description/
                      Lost_Source_Packet
                   let $missings := 
                   (
                      for $field_to_check in $fields_to_check
                      let $missing_line_num:=xs:integer(data ($field_to_check/NUMBER_OF_SP_ERROR))*16
                      let $degradation_type:=data ($field_to_check/DEGRADATION_TYPE)
                      return
                         concat (
                            "@MISSING_LINES(", 
                               data($field_to_check/@band_Id), ",",
                               data($field_to_check/@detector_Id), ")@",$missing_line_num, "@ ",
                            "@DEGRADATION_TYPE(", 
                               data($field_to_check/@band_Id), ",",
                               data($field_to_check/@detector_Id), ")@",$degradation_type , "@")
                   )
                   return 
                      concat (
                         "Number of missing lines exceeds the threshold (",
                                $threshold, ") ", string-join ($missings,' '))
               
               ]]></failureMessage>
            </xqueryInspection>

            <xqueryInspection version="1.0" id="Degraded_Packets">
               <name>Check the number of degraded packets</name>
               <thematic>GENERAL_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">0</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold as xs:positiveInteger* external;
                   let $degraded_packets := *[matches(name(), ".*_DataStrip_ID")]/
                      Image_Data_Info/Sensor_Configuration/Source_Packet_Description/Degradation_Summary/NUMBER_OF_TOO_DEGRADED_PACKETS
                   return
                   if (fn:empty ($degraded_packets))
                   then
                      fn:true()
                   else
                      xs:double(data($degraded_packets)) <= xs:double($threshold)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  declare variable $threshold as xs:positiveInteger* external;
                  let $degraded_packets := *[matches(name(), ".*_DataStrip_ID")]/
                     Image_Data_Info/Sensor_Configuration/Source_Packet_Description/Degradation_Summary/NUMBER_OF_TOO_DEGRADED_PACKETS
                  return
                  if (fn:empty ($degraded_packets))
                  then
                     "NUMBER_OF_TOO_DEGRADED_PACKETS not found in dataset"
                  else
                     concat ("NUMBER_OF_TOO_DEGRADED_PACKETS value ", data($degraded_packets), " does not exceed the threshold (", $threshold ,") ",
                        "@NUMBER_OF_TOO_DEGRADED_PACKETS@", data($degraded_packets), "@" )
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  declare variable $threshold as xs:positiveInteger* external;
                  let $degraded_packets := *[matches(name(), ".*_DataStrip_ID")]/
                     Image_Data_Info/Sensor_Configuration/Source_Packet_Description/Degradation_Summary/NUMBER_OF_TOO_DEGRADED_PACKETS
                  let $kept_degraded := *[matches(name(), ".*_DataStrip_ID")]/
                     Image_Data_Info/Sensor_Configuration/Source_Packet_Description/Degradation_Summary/NUMBER_OF_KEPT_DEGRADED_PACKETS
                  return
                     concat ("NUMBER_OF_TOO_DEGRADED_PACKETS value ", data($degraded_packets), " exceeds the threshold (", $threshold ,"). DEGRADED PACKETS KEPT: ", data($kept_degraded),
                        "@NUMBER_OF_LOST_PACKETS@", data($degraded_packets), "@",
                        "@NUMBER_OF_KEPT_DEGRADED_PACKETS@", data($kept_degraded), "@")
               
               ]]></failureMessage>
            </xqueryInspection>



            <xqueryInspection version="1.0" id="Datation_Model_RMOY">
               <name>Check the correctness of the Datation model with RMOY.</name>
               <thematic>SENSOR_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">6</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold as xs:positiveInteger* external;
                   let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                      Image_Data_Info/Sensor_Configuration/Time_Stamp/
                      Quality_Indicators/Global/RMOY
                   return
                   if (fn:empty ($fields_to_check))
                   then
                      fn:true()
                   else
                      xs:double(data($fields_to_check)) <= xs:double($threshold)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  declare variable $threshold as xs:positiveInteger* external;
                  let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                     Image_Data_Info/Sensor_Configuration/Time_Stamp/
                     Quality_Indicators/Global/RMOY
                  return
                  if (fn:empty ($fields_to_check))
                  then
                     "RMOY not found in dataset"
                  else
                     concat ("RMOY value ", data($fields_to_check), 
                        " does not exceed the threshold (", $threshold ,") ",
                        "@RMOY@", data($fields_to_check), "@" )
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  declare variable $threshold as xs:positiveInteger* external;
                  let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                     Image_Data_Info/Sensor_Configuration/Time_Stamp/
                     Quality_Indicators/Global/RMOY
                  return
                     concat ("RMOY value ", data($fields_to_check), 
                        " exceeds the threshold (", $threshold ,") ",
                        "@RMOY@", data($fields_to_check), "@" )
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Datation_Model_GPS_SYNC">
               <name>Check the correctness of the Datation model with GPS_SYNC.</name>
               <thematic>SENSOR_QUALITY</thematic>
               <query><![CDATA[
                  
                   let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                      Image_Data_Info/Sensor_Configuration/Time_Stamp/GPS_SYNC
                   return
                      xs:boolean($fields_to_check)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "GPS is synchronized."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  "GPS is not synchronized."
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="Orbit_Number_DOWNLINK">
               <name>Check the consistency of downlink orbit number.</name>
               <thematic>GENERAL_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold_min">1</parameter>
                  <parameter name="threshold_max">99999</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold_min as xs:positiveInteger* external;
                   declare variable $threshold_max as xs:positiveInteger* external;
                   
                   let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                      General_Info/Downlink_Info/DOWNLINK_ORBIT_NUMBER
                   return
                   if (fn:empty ($fields_to_check))
                   then
                      fn:false()
                   else
                      (xs:integer(data($fields_to_check)) > xs:integer($threshold_min)) and
                      (xs:integer(data($fields_to_check)) < xs:integer($threshold_max))
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  declare variable $threshold_min as xs:positiveInteger* external;
                  declare variable $threshold_max as xs:positiveInteger* external;
                   
                  let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                     General_Info/Downlink_Info/DOWNLINK_ORBIT_NUMBER
                  return
                     concat ("Downlink Orbit number (",data($fields_to_check),
                         ") is in range [", $threshold_min, ",", $threshold_max ,"] ",
                        "@DOWNLINK_ORBIT_NUMBER@", data($fields_to_check), "@" )
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  declare variable $threshold_min as xs:positiveInteger* external;
                  declare variable $threshold_max as xs:positiveInteger* external;
                  let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                     General_Info/Downlink_Info/DOWNLINK_ORBIT_NUMBER
                  return
                     if (fn:empty ($fields_to_check))
                     then
                        "Unknown downlink orbit number"
                     else
                        concat ("Downlink orbit number (",data($fields_to_check),
                         ") is not in range [", $threshold_min, ",", $threshold_max ,"] ",
                        "@DOWNLINK_ORBIT_NUMBER@", data($fields_to_check), "@" )
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="Relative_Orbit_Number_SENSING">
               <name>Check the consistency of relative imaging orbit number.</name>
               <thematic>GENERAL_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold_min">1</parameter>
                  <parameter name="threshold_max">143</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $threshold_min as xs:positiveInteger* external;
                   declare variable $threshold_max as xs:positiveInteger* external;
                   
                   let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                      General_Info/Datatake_Info/SENSING_ORBIT_NUMBER
                   return
                   if (fn:empty ($fields_to_check))
                   then
                      fn:false()
                   else
                      (xs:integer(data($fields_to_check)) >= xs:integer($threshold_min)) and
                      (xs:integer(data($fields_to_check)) <= xs:integer($threshold_max))
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  declare variable $threshold_min as xs:positiveInteger* external;
                  declare variable $threshold_max as xs:positiveInteger* external;
                  let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                     General_Info/Datatake_Info/SENSING_ORBIT_NUMBER
                  return
                     concat ("Sensing orbit number (",data($fields_to_check),
                         ") is in range [", $threshold_min, ",", $threshold_max ,"] ",
                        "@SENSING_ORBIT_NUMBER@", data($fields_to_check), "@" )
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  declare variable $threshold_min as xs:positiveInteger* external;
                  declare variable $threshold_max as xs:positiveInteger* external;
                  let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                     General_Info/Datatake_Info/SENSING_ORBIT_NUMBER
                  return
                     if (fn:empty ($fields_to_check))
                     then
                        "Unknown sensing orbit number."
                     else
                        concat ("Sensing orbit number (",data($fields_to_check),
                         ") is not in range [", $threshold_min, ",", $threshold_max ,"] ",
                        "@SENSING_ORBIT_NUMBER@", data($fields_to_check), "@" )
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="Attitude_Quality_Indicator_Raw">
               <name>Check the admissibility of Raw Attitude Quality Indicator.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="expected_indicators">"APRIORIATT|COARSEATT|UNCONFATT|VALIDATT"
                  </parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $expected_indicators as xs:string* external;
                   let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                      Satellite_Ancillary_Data_Info/Attitudes/Raw_Attitudes/
                      STR_List/STR[1]/Attitude_Data_List/Attitude_Data
                      
                   let $attitude_count := count($fields_to_check)
                   let $step := $attitude_count/100
                   let $wrong_attitudes :=
                   (
                      for $attitude in $fields_to_check[position() mod $step = 0]
                      let $indicator := data($attitude/ATTITUDE_QUALITY)
                      where not(matches($indicator, $expected_indicators))
                      return $attitude
                   )
                   return empty ($wrong_attitudes)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "No wrong raw attitude indicators were found."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  "Some wrong raw attitude indicators were found."
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="Attitude_Quality_Indicator_Corrected">
               <name>Check the admissibility of Corrected Attitude Quality Indicator.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="expected_indicators">"PROPAGATED|ONE_VALID_STR|TWO_VALID_STR"
                  </parameter>
               </queryParameters>
               <query><![CDATA[
                  
                   declare variable $expected_indicators as xs:string* external;
                   let $fields_to_check := *[matches(name(), ".*_DataStrip_ID")]/
                      Satellite_Ancillary_Data_Info/Attitudes/
                      Corrected_Attitudes/Values
                   let $attitude_count := count($fields_to_check)
                   let $step := $attitude_count/100
                   let $wrong_attitudes :=
                   (
                      for $attitude in $fields_to_check[position() mod $step = 0]
                      let $indicator := data($attitude/ATTITUDE_QUALITY_INDICATOR)
                      where not(matches($indicator, $expected_indicators))
                      return $attitude
                   )
                   return empty ($wrong_attitudes)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "No wrong corrected attitude indicators were found."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  "Some wrong corrected attitude indicators were found."
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Start_Stop_Time">
               <name>Check start/stop time validity.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                   let $start := *[matches(name(), ".*_DataStrip_ID")]/
                      General_Info/Datastrip_Time_Info/DATASTRIP_SENSING_START
                   let $stop := *[matches(name(), ".*_DataStrip_ID")]/
                      General_Info/Datastrip_Time_Info/DATASTRIP_SENSING_STOP
                   return 
                      data($start) <= data($stop)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  let $start := *[matches(name(), ".*_DataStrip_ID")]/
                     General_Info/Datastrip_Time_Info/DATASTRIP_SENSING_START
                  let $stop := *[matches(name(), ".*_DataStrip_ID")]/
                     General_Info/Datastrip_Time_Info/DATASTRIP_SENSING_STOP
                  return 
                  concat (
                     "Sensing period is valid. ",
                        "@SENSING_START@",$start,"@ ",
                        "@SENSING_STOP@",$stop,"@")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  let $start := *[matches(name(), ".*_DataStrip_ID")]/
                     General_Info/Datastrip_Time_Info/DATASTRIP_SENSING_START
                  let $stop := *[matches(name(), ".*_DataStrip_ID")]/
                     General_Info/Datastrip_Time_Info/DATASTRIP_SENSING_STOP
                  return 
                  concat (
                     "Sensing period is invalid. ",
                        "@SENSING_START@",$start,"@ ",
                        "@SENSING_STOP@",$stop,"@")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xmlSchemaInspection version="1.0"
               id="schemaXmlValidator">
               <name>Schema Validator.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[.]]></query>
               <failureLimit>100</failureLimit>
            </xmlSchemaInspection>
            <xqueryInspection version="1.0" id="Granule_Dimensions_10m">
               <name>Check the 10m consistency of granules/tiles.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <query><![CDATA[
                  
                  let $meta_size := *[matches (name(), "(MTD_TL\.xml|\w{8}_MTD_L1[ABC]_.*\.xml)")]/ 
                     *[matches(name(),"Level-.._(Granule|Tile)_ID")]/Geometric_Info/
							*[matches(name(), "(Granule_Dimensions|Tile_Geocoding)")]/Size[@resolution="10"]
                  let $granules1 := IMG_DATA/*[matches (name(), ".*_(B02|B03|B04|B08)\.jp2")]
                  let $granules2 := IMG_DATA/R10m/*[matches (name(), ".*_10m\.jp2")]
                  let $granules := ($granules1, $granules2)
                  (: 10 m :)
                  let $error := 
                     for $granule in $granules
                     where not(
                        xs:integer($granule/image/directory/Width) = xs:integer($meta_size/NCOLS) and
                        xs:integer($granule/image/directory/Height) = xs:integer($meta_size/NROWS))
                     return
                        "true"
                  return 
                    fn:empty($error)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "10m resolution granules/tiles dimensions are correct."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  let $meta_size := *[matches (name(), "(MTD_TL\.xml|\w{8}_MTD_L1[ABC]_.*\.xml)")]/
                     *[matches(name(),"Level-.._(Granule|Tile)_ID")]/Geometric_Info/
                     *[matches(name(), "(Granule_Dimensions|Tile_Geocoding)")]/Size[@resolution="10"]
                  let $granules1 := IMG_DATA/*[matches (name(), ".*_(B02|B03|B04|B08)\.jp2")]
                  let $granules2 := IMG_DATA/R10m/*[matches (name(), ".*_10m\.jp2")]
                  let $granules := ($granules1, $granules2)
                  (: 10 m :)
                  return
                  concat ("Wrong 10m resolution granules/tiles dimensions. ",
                     "@EXPECTED@",  data($meta_size/NCOLS), ",", 
                                     data($meta_size/NROWS), "@ ",
                     string-join (
                        for $granule in $granules
                        where not(
                           xs:integer($granule/image/directory/Width)=xs:integer($meta_size/NCOLS) and
                           xs:integer($granule/image/directory/Height)=xs:integer($meta_size/NROWS))
                        return
									let $band := fn:replace(name($granule), ".*_(B02|B03|B04|B08).jp2", "$1")
                           return
                              concat ("@BAND(", $band, ")@", 
                                 data($granule/image/directory/Width), ",",
                                 data($granule/image/directory/Height), "@ "), ' '))
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Granule_Dimensions_20m">
               <name>Check the 20m consistency of granules/tiles.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <query><![CDATA[
                  
                  let $meta_size := *[matches (name(), "(MTD_TL\.xml|\w{8}_MTD_L1[ABC]_.*\.xml)")]/
                    *[matches(name(),"Level-.._(Granule|Tile)_ID")]/Geometric_Info/
                     *[matches(name(), "(Granule_Dimensions|Tile_Geocoding)")]/Size[@resolution="20"]
                  let $granules1 := IMG_DATA/*[matches (name(), ".*_(B05|B06|B07|B8A|B11|B12)\.jp2")]
                  let $granules2 := IMG_DATA/R20m/*[matches (name(), ".*_20m\.jp2")]
                  let $granules := ($granules1, $granules2)
                  (: 20 m :)
                  let $error := 
                     for $granule in $granules
                     where not(
                        xs:integer($granule/image/directory/Width)=xs:integer($meta_size/NCOLS) and
                        xs:integer($granule/image/directory/Height)=xs:integer($meta_size/NROWS))
                     return
                        "true"
                  return 
                    fn:empty($error)                  
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "20m resolution granules/tiles dimensions are correct."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  let $meta_size := *[matches (name(), "(MTD_TL\.xml|\w{8}_MTD_L1[ABC]_.*\.xml)")]/
                     *[matches(name(),"Level-.._(Granule|Tile)_ID")]/Geometric_Info/
                     *[matches(name(), "(Granule_Dimensions|Tile_Geocoding)")]/Size[@resolution="20"]          
                  let $granules1 := IMG_DATA/*[matches (name(), ".*_(B05|B06|B07|B8A|B11|B12)\.jp2")]
                  let $granules2 := IMG_DATA/R20m/*[matches (name(), ".*_20m\.jp2")]
                  let $granules := ($granules1, $granules2)
                  (: 20 m :)                  
                  return
                  concat ("Wrong 20m resolution granules/tiles dimensions. ",
                     "@EXPECTED@",  data($meta_size/NCOLS), ",", 
                                     data($meta_size/NROWS), "@ ",
                     string-join (
                        for $granule in $granules
                        where not(
                           xs:integer($granule/image/directory/Width)=xs:integer($meta_size/NCOLS) and 
                           xs:integer($granule/image/directory/Height)=xs:integer($meta_size/NROWS))
                        return
									let $band := fn:replace(name($granule), ".*_(B05|B06|B07|B8A|B11|B12).jp2", "$1")
                           return
                              concat ("@BAND(", $band, ")@", 
                                 data($granule/image/directory/Width), ",",
                                 data($granule/image/directory/Height), "@ "), ' '))               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Granule_Dimensions_60m">
               <name>Check the 60m consistency of granules/tiles.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <query><![CDATA[
                  
                  let $meta_size := *[matches (name(), "(MTD_TL\.xml|\w{8}_MTD_L1[ABC]_.*\.xml)")]/
                     *[matches(name(),"Level-.._(Granule|Tile)_ID")]/Geometric_Info/
                     *[matches(name(), "(Granule_Dimensions|Tile_Geocoding)")]/Size[@resolution="60"]
                  let $granules1 := IMG_DATA/*[matches (name(), ".*_(B01|B09|B10)\.jp2")]
                  let $granules2 := IMG_DATA/R60m/*[matches (name(), ".*_60m\.jp2")]
                  let $granules := ($granules1, $granules2)
                  (: 60 m :)
                  let $error := 
                     for $granule in $granules
                     where not(
                        xs:integer($granule/image/directory/Width) = xs:integer($meta_size/NCOLS) and
                        xs:integer($granule/image/directory/Height) = xs:integer($meta_size/NROWS))
                     return
                        "true"
                  return 
                    fn:empty($error)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  "60m resolution granules/tiles dimensions are correct."
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  let $meta_size := *[matches (name(), "(MTD_TL\.xml|\w{8}_MTD_L1[ABC]_.*\.xml)")]/
                     *[matches(name(),"Level-.._(Granule|Tile)_ID")]/Geometric_Info/
                     *[matches(name(), "(Granule_Dimensions|Tile_Geocoding)")]/Size[@resolution="60"]
                  let $granules1 := IMG_DATA/*[matches (name(), ".*_(B01|B09|B10)\.jp2")]
                  let $granules2 := IMG_DATA/R60m/*[matches (name(), ".*_60m\.jp2")]
                  let $granules := ($granules1, $granules2)
                  (: 60 m :)
                  return
                  concat ("Wrong 60m resolution granules/tiles dimensions. ",
                     "@EXPECTED@",  data($meta_size/NCOLS), ",", 
                                     data($meta_size/NROWS), "@ ",
                     string-join (
                        for $granule in $granules
                        where not (
                           xs:integer($granule/image/directory/Width) = xs:integer($meta_size/NCOLS) and
                           xs:integer($granule/image/directory/Height) = xs:integer($meta_size/NROWS))
                        return
									let $band := fn:replace(name($granule), ".*_(B01|B09|B10).jp2", "$1")
                           return
                              concat ("@BAND(", $band, ")@", 
                                 data($granule/image/directory/Width), ",",
                                 data($granule/image/directory/Height), "@ "), ' '))
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Granule_Footprint">
               <name>Check the consistency of footprint.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">1.5</parameter>
                  <parameter name="width">1.5</parameter>
                  <parameter name="height">1.5</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                     declare variable $threshold as xs:double* external;
                     declare variable $width as xs:double* external;
                     declare variable $height as xs:double* external;
                     
                     declare function local:trim ($arg as xs:string) as xs:string
                     {
                        replace(replace(replace($arg,'\s+$',''),'^\s+',''), '\s+', ' ')
                     };
                     declare function local:formatFootprintExt ($footprint as xs:string) as xs:string*
                     {
                        let $list := fn:tokenize ($footprint, " ")
                        return
                           for $coord at $position in $list
                           where (($position - 1) mod 3)=0
                           return
                              concat ($list[$position]," ",$list[$position+1]," ",$list[$position+2])
                     };
                     
                     declare function local:convertCoord ($point as xs:string) as xs:double*
                     {
                        let $tk := fn:tokenize ($point, " ") 
                        let $lat := $tk[1]
                        let $lon := $tk[2]
                        let $alt := $tk[3]
                        return
                           (xs:double($lat),xs:double($lon), xs:double($alt)) 
                     };
                     
                     declare function local:ul ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[1])
                     };
                     
                     declare function local:ll ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[2])
                     };
                     
                     declare function local:lr ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[3])
                     };

                     declare function local:ur ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[4])
                     };
                     
                     declare function local:distance ($p1 as xs:double*, $p2 as xs:double*)
                     {
                        math:sqrt(math:power($p2[1]-$p1[1],2)+math:power(fn:min((fn:abs($p2[2]-$p1[2]),360-fn:abs($p2[2]-$p1[2]))),2))
                     };
                     
                     declare function local:toString ($p1 as xs:double*)
                     {
                        concat ("(",$p1[1], ",", $p1[2], ", ", $p1[3],")")
                     };
                     
                     let $footprint_ext := fn:data(*[matches(name(), ".*_Granule_ID")]/
                        Geometric_Info/Granule_Footprint/Granule_Footprint/Footprint/EXT_POS_LIST)
                        
                     let $footprint_int := fn:data(*[matches(name(), ".*_Granule_ID")]/
                        Geometric_Info/Granule_Footprint/Granule_Footprint/Footprint/INT_POS_LIST)
                     
                     let $footprint := 
                     ( 
                        if (fn:empty($footprint_int))
                        then
                           if (fn:empty($footprint_ext)) then ()
                           else local:formatFootprintExt(local:trim($footprint_ext)) 
                        else $footprint_int
                     )
                     (:
                     let $dummy5 := trace ("", concat ("Distance ul ", local:toString(local:ul($footprint))))
                     let $dummy6 := trace ("", concat ("Distance ll ", local:toString(local:ll($footprint))))
                     let $dummy7 := trace ("", concat ("Distance lr ", local:toString(local:lr($footprint))))
                     let $dummy8 := trace ("", concat ("Distance ur ", local:toString(local:ur($footprint))))
                     
                     let $dummy1 := trace ("", concat ("Distance ul->ur ",local:distance (local:ul($footprint), local:ur($footprint))))
                     let $dummy2 := trace ("", concat ("Distance ll->lr ",local:distance (local:ll($footprint), local:lr($footprint))))
                     let $dummy3 := trace ("", concat ("Distance ul->ll ",local:distance (local:ul($footprint), local:ll($footprint))))
                     let $dummy4 := trace ("", concat ("Distance ur->lr ",local:distance (local:ur($footprint), local:lr($footprint))))

                     let $dummy9 := trace ("", concat ("Distance ul->ur - width ",math:abs(local:distance (local:ul($footprint), local:ur($footprint))-$width)))
                     let $dummy10 := trace ("", concat ("Distance ll->lr - width ",math:abs(local:distance (local:ll($footprint), local:lr($footprint))-$width)))
                     let $dummy11 := trace ("", concat ("Distance ul->ll - width ",math:abs(local:distance (local:ul($footprint), local:ll($footprint))-$height)))
                     let $dummy12 := trace ("", concat ("Distance ur->lr - width ",math:abs(local:distance (local:ur($footprint), local:lr($footprint))-$height)))

                     :)

                     let $dummy12 := math:abs(local:distance (local:ur($footprint), local:lr($footprint))-$height)

                     return
                        if (empty($footprint))
                        then
                           xs:boolean ("false")
                        else
                           (math:abs(local:distance (local:ul($footprint), local:ur($footprint))-$width) < $threshold) and
                           (math:abs(local:distance (local:ll($footprint), local:lr($footprint))-$width) < $threshold) and
                           (math:abs(local:distance (local:ul($footprint), local:ll($footprint))-$height) < $threshold) and
                           (math:abs(local:distance (local:ur($footprint), local:lr($footprint))-$height) < $threshold)
                  
               ]]></query>
               <successMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     declare function local:trim ($arg as xs:string) as xs:string
                     {
                        replace(replace(replace($arg,'\s+$',''),'^\s+',''), '\s+', ' ')
                     };
                     declare function local:formatFootprintExt ($footprint as xs:string) as xs:string*
                     {
                        let $list := fn:tokenize ($footprint, " ")
                        return
                           for $coord at $position in $list
                           where (($position - 1) mod 3)=0
                           return
                              concat ($list[$position]," ",$list[$position+1]," ",$list[$position+2])
                     };
                     
                     declare function local:convertCoord ($point as xs:string) as xs:double*
                     {
                        let $tk := fn:tokenize ($point, " ") 
                        let $lat := $tk[1]
                        let $lon := $tk[2]
                        let $alt := $tk[3]
                        return
                           (xs:double($lat),xs:double($lon), xs:double($alt)) 
                     };
                     
                     declare function local:ul ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[1])
                     };
                     
                     declare function local:ll ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[2])
                     };
                     
                     declare function local:lr ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[3])
                     };

                     declare function local:ur ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[4])
                     };
                     
                     declare function local:distance ($p1 as xs:double*, $p2 as xs:double*)
                     {
                        math:sqrt(math:power($p2[1]-$p1[1],2)+math:power(fn:min((fn:abs($p2[2]-$p1[2]),360-fn:abs($p2[2]-$p1[2]))),2))
                     };
                     
                     declare function local:toString ($p1 as xs:double*)
                     {
                        concat ($p1[1], ",", $p1[2], ", ", $p1[3])
                     };
                     
                     
                     let $footprint_ext := fn:data(*[matches(name(), ".*_Granule_ID")]/
                        Geometric_Info/Granule_Footprint/Granule_Footprint/Footprint/EXT_POS_LIST)
                     let $footprint_int := fn:data(*[matches(name(), ".*_Granule_ID")]/
                        Geometric_Info/Granule_Footprint/Granule_Footprint/Footprint/INT_POS_LIST)
                     
                     let $footprint := 
                     (
                        if (fn:empty ($footprint_int))
                        then
                           if (fn:empty($footprint_ext)) then ()
                           else local:formatFootprintExt(local:trim($footprint_ext)) 
                        else $footprint_int
                     )
                     return
                        concat ("Footprint is valid.",
                           "@UL@", local:toString(local:ul($footprint)), "@ ",
                           "@LL@", local:toString(local:ll($footprint)), "@ ",
                           "@LR@", local:toString(local:lr($footprint)), "@ ",
                           "@UR@", local:toString(local:ur($footprint)), "@ ",
                           "@DISTANCE(UL,UR)@", local:distance (local:ul($footprint), local:ur($footprint)), "@ ",
                           "@DISTANCE(LL,LR)@", local:distance (local:ll($footprint), local:lr($footprint)), "@ ",
                           "@DISTANCE(UL,LL)@", local:distance (local:ul($footprint), local:ll($footprint)), "@ ",
                           "@DISTANCE(UR,LR)@", local:distance (local:ur($footprint), local:lr($footprint)), "@ ")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     declare function local:trim ($arg as xs:string) as xs:string
                     {
                        replace(replace(replace($arg,'\s+$',''),'^\s+',''), '\s+', ' ')
                     };
                     declare function local:formatFootprintExt ($footprint as xs:string) as xs:string*
                     {
                        let $list := fn:tokenize ($footprint, " ")
                        return
                           for $coord at $position in $list
                           where (($position - 1) mod 3)=0
                           return
                              concat ($list[$position]," ",$list[$position+1]," ",$list[$position+2])
                     };
                     
                     declare function local:convertCoord ($point as xs:string) as xs:double*
                     {
                        let $tk := fn:tokenize ($point, " ") 
                        let $lat := $tk[1]
                        let $lon := $tk[2]
                        let $alt := $tk[3]
                        return
                           (xs:double($lat),xs:double($lon), xs:double($alt)) 
                     };
                     
                     declare function local:ul ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[1])
                     };
                     
                     declare function local:ll ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[2])
                     };
                     
                     declare function local:lr ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[3])
                     };

                     declare function local:ur ($footprint as xs:string*) as xs:double*
                     {
                        local:convertCoord ($footprint[4])
                     };
                     
                     declare function local:distance ($p1 as xs:double*, $p2 as xs:double*)
                     {
                        math:sqrt(math:power($p2[1]-$p1[1],2)+math:power(fn:min((fn:abs($p2[2]-$p1[2]),360-fn:abs($p2[2]-$p1[2]))),2))
                     };
                     
                     declare function local:toString ($p1 as xs:double*)
                     {
                        concat ("(",$p1[1], ",", $p1[2], ", ", $p1[3],")")
                     };
                     
                     
                     let $footprint_ext := fn:data(*[matches(name(), ".*_Granule_ID")]/
                        Geometric_Info/Granule_Footprint/Granule_Footprint/Footprint/EXT_POS_LIST)
                     let $footprint_int := fn:data(*[matches(name(), ".*_Granule_ID")]/
                        Geometric_Info/Granule_Footprint/Granule_Footprint/Footprint/INT_POS_LIST)
                     
                     let $footprint := 
                        if (fn:empty ($footprint_int))
                        then
                           if (fn:empty($footprint_ext)) then ()
                           else local:formatFootprintExt(local:trim($footprint_ext)) 
                        else $footprint_int
                     return
                        if (empty($footprint))
                        then
                           "No footprint found in this product."
                        else
                           concat ("Footprint is invalid.",
                              "@UL@", local:toString(local:ul($footprint)), "@ ",
                              "@LL@", local:toString(local:ll($footprint)), "@ ",
                              "@LR@", local:toString(local:lr($footprint)), "@ ",
                              "@UR@", local:toString(local:ur($footprint)), "@ ",
                              "@DISTANCE(UL,UR)@", local:distance (local:ul($footprint), local:ur($footprint)), "@ ",
                              "@DISTANCE(LL,LR)@", local:distance (local:ll($footprint), local:lr($footprint)), "@ ",
                              "@DISTANCE(UL,LL)@", local:distance (local:ul($footprint), local:ll($footprint)), "@ ",
                              "@DISTANCE(UR,LR)@", local:distance (local:ur($footprint), local:lr($footprint)), "@ ")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Solar_Angle_Azimuth">
               <name>Check the azimuth solar angle.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">360</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Solar_Angles|Mean_Sun_Angle")]/AZIMUTH_ANGLE)
                     return
                        $value>0 and $value<$threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Solar_Angles|Mean_Sun_Angle")]/AZIMUTH_ANGLE)
                     return
                        concat ("Azimuth solar angle (", $value, 
                           ") is in the limit of the threshold (", $threshold, ") ",
                           "@EXPECTED@", $threshold, "@",
                           "@SOLAR_AZIMUTH_ANGLE@", $value, "@")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Solar_Angles|Mean_Sun_Angle")]/AZIMUTH_ANGLE)
                     return
                        if (empty ($value)) then "Solar azimuth angle not found."
                        else
                        concat ("Azimuth solar angle (", $value, 
                           ") is out of the threshold limit (", $threshold, ") ",
                           "@EXPECTED@", $threshold, "@",
                           "@SOLAR_AZIMUTH_ANGLE@", $value, "@")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Solar_Angle_Zenith">
               <name>Check the zenith solar angle.</name>
               <thematic>GENERAL_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">180</parameter>
                  <parameter name="l1_threshold">82</parameter>
                  <parameter name="l2a_threshold">70</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Solar_Angles|Mean_Sun_Angle")]/ZENITH_ANGLE)
                     return
                        $value>0 and $value<$threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                     declare variable $l1_threshold as xs:double* external;
                     declare variable $l2a_threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Solar_Angles|Mean_Sun_Angle")]/ZENITH_ANGLE)
                     let $tile_id := xs:string(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        General_Info//*[matches(name(), "(TILE|GRANULE)_ID")])
                     return
                     if (matches($tile_id, ".*_L2A_.*"))
                     then
                        if ($value > $l2a_threshold)
                        then
                           concat ("WARNING: Zenith solar angle (", $value, 
                           ") is above recommended Level-2 threshold limit (", $l2a_threshold, "). Please see the L2A Data Quality Report for more information.",
                           "@EXPECTED@", $l2a_threshold, "@",
                           "@SOLAR_ZENITH_ANGLE@", $value, "@")
                        else
                           concat ("Zenith solar angle (", $value, 
                           ") is within the threshold limit (", $l2a_threshold, ") ",
                           "@EXPECTED@", $l2a_threshold, "@",
                           "@SOLAR_ZENITH_ANGLE@", $value, "@")
                     else
                        if ($value > $l1_threshold)
                        then
                           concat ("WARNING: Zenith solar angle (", $value, 
                           ") is above recommended threshold limit (", $l1_threshold, "). Please see the L1C Data Quality Report for more information.",
                           "@EXPECTED@", $l1_threshold, "@",
                           "@SOLAR_ZENITH_ANGLE@", $value, "@")
                        else
                           concat ("Zenith solar angle (", $value, 
                           ") is within the threshold limit (", $l1_threshold, ") ",
                           "@EXPECTED@", $l1_threshold, "@",
                           "@SOLAR_ZENITH_ANGLE@", $value, "@")

               ]]></successMessage>
               <failureMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Solar_Angles|Mean_Sun_Angle")]/ZENITH_ANGLE)
                     return
                        if (empty ($value)) then "Solar zenith angle not found."
                        else 
                           concat ("Zenith solar angle (", $value, 
                           ") is out of the threshold limit (", $threshold, ") ",
                           "@EXPECTED@", $threshold, "@",
                           "@SOLAR_ZENITH_ANGLE@", $value, "@")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Incidence_Angle_Azimuth">
               <name>Check the azimuth incidence angle.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">360</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double((*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Incidence_Angles|Mean_Viewing_Incidence_Angle")])[1]/AZIMUTH_ANGLE)
                     return
                        $value>0 and $value<$threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double((*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Incidence_Angles|Mean_Viewing_Incidence_Angle")])[1]/AZIMUTH_ANGLE)
                     return
                        concat ("Azimuth incidence angle (", $value, 
                           ") is in the limit of the threshold (", $threshold, ") ",
                           "@EXPECTED@", $threshold, "@",
                           "@INCIDENCE_AZIMUTH_ANGLE@", $value, "@")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double((*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Incidence_Angles|Mean_Viewing_Incidence_Angle")])[1]/AZIMUTH_ANGLE)
                     return
                        if (empty ($value)) then "Azimuth incidence angle not found."
                        else 
                        concat ("Azimuth incidence angle (", $value, 
                           ") is out of the threshold limit (", $threshold, ") ",
                           "@EXPECTED@", $threshold, "@",
                           "@INCIDENCE_AZIMUTH_ANGLE@", $value, "@")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Incidence_Angle_Zenith">
               <name>Check the zenith incidence angle.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">180</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double((*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Incidence_Angles|Mean_Viewing_Incidence_Angle")])[1]/ZENITH_ANGLE)
                     return
                        $value>0 and $value<$threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double((*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Incidence_Angles|Mean_Viewing_Incidence_Angle")])[1]/ZENITH_ANGLE)
                     return
                        concat ("Zenith incidence angle (", $value, 
                           ") is in the limit of the threshold (", $threshold, ") ",
                           "@EXPECTED@", $threshold, "@",
                           "@INCIDENCE_ZENITH_ANGLE@", $value, "@")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double((*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Geometric_Info//*[matches(name(), "Incidence_Angles|Mean_Viewing_Incidence_Angle")])[1]/ZENITH_ANGLE)
                     return
                        if (empty ($value)) then "Zenith incidence angle not found."
                        else
                        concat ("Zenith incidence angle (", $value, 
                           ") is out of the threshold limit (", $threshold, ") ",
                           "@EXPECTED@", $threshold, "@",
                           "@INCIDENCE_ZENITH_ANGLE@", $value, "@")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Perc_Cloud_Coverage">
               <name>Check the percentage of cloud coverage.</name>
               <thematic>GENERAL_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">5</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Quality_Indicators_Info/Image_Content_QI/CLOUDY_PIXEL_PERCENTAGE)
                     return
                        $value<$threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Quality_Indicators_Info/Image_Content_QI/CLOUDY_PIXEL_PERCENTAGE)
                     return
                        concat ("Cloudy pixel percentage(", $value, 
                           ") is lower than the threshold (", $threshold, ") ",
                           "@EXPECTED@", $threshold, "@",
                           "@CLOUDY_PERCENTAGE@", $value, "@")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_(Granule|Tile)_ID")]/
                        Quality_Indicators_Info/Image_Content_QI/CLOUDY_PIXEL_PERCENTAGE)
                     return
                        concat ("Cloudy pixel percentage(", $value, 
                           ") exceeds the threshold (", $threshold, ") ",
                           "@EXPECTED@", $threshold, "@",
                           "@CLOUDY_PERCENTAGE@", $value, "@")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Processor_Version">
               <name>Check the processor version.</name>
               <thematic>GENERAL_QUALITY</thematic>
               <query><![CDATA[
                  (: WARNING: This inspection requires that 
                     class fr.gael.olqc.item.GipProbas to be in the
                     classpath otherwise an error will be raised for this
                     check. :) 
                  declare namespace gip_probas="java:fr.gael.olqc.item.GipProbas";

                  let $value := fn:data(*[matches(name(), "Level.*_ID")]/
                     General_Info/Processing_Info/PROCESSING_BASELINE)
                        
                  let $baseline := gip_probas:getBaselineVersion()
                     
                  return
                     if (empty ($value))
                     then
                        fn:false()
                     else
                        $value = $baseline
               ]]></query>
               <successMessage><![CDATA[
                     let $value := fn:data(*[matches(name(), "Level.*_ID")]/
                        General_Info/Processing_Info/PROCESSING_BASELINE)
                     return
                        concat ("Processor version is valid (", 
                           $value, ") @PROCESSOR_VERSION@", $value, "@")
               ]]></successMessage>
               <failureMessage><![CDATA[
                  declare namespace gip_probas="java:fr.gael.olqc.item.GipProbas";

                  let $value := fn:data(*[matches(name(), "Level.*_ID")]/
                        General_Info/Processing_Info/PROCESSING_BASELINE)
                  
                  let $baseline := gip_probas:getBaselineVersion()
                  
                  return
                  if (empty ($value))
                  then
                     concat ("Processor version is invalid (version is empty, ", 
                              "expected value: " , $baseline , ") ", 
                              "@PROCESSOR_VERSION@empty@ ",
                              "@EXPECTED@", $baseline, "@")
                        else
                           concat ("Processor version is invalid (found:", 
                              $value, ", expected value: " , $baseline , ") ",
                              "@PROCESSOR_VERSION@", $value, "@ ",
                              "@EXPECTED@", $baseline, "@")
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Ephemeris_Quality">
               <name>Check the ephemeris quality value.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">20</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Geometric_Info//EPHEMERIS_QUALITY)
                     return
                        $value <= $threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Geometric_Info//EPHEMERIS_QUALITY)
                     return
                     concat ("Ephemeris quality is valid (", 
                        $value, "<=", $threshold, ") @VALUE@", $value, "@ @EXPECTED@", $threshold, "@")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Geometric_Info//EPHEMERIS_QUALITY)
                     return
                     concat ("Ephemeris quality is invalid (", 
                        $value, ">", $threshold, ") @VALUE@", $value, "@ @EXPECTED@", $threshold, "@")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Planimetric_Stability">
               <name>Check the planimetric stability value </name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">5</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Geometric_Info//Planimetric_Stability/VALUE)
                     return
                        $value < $threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Geometric_Info//Planimetric_Stability/VALUE)
                     return
                     concat ("Planimetric stability is valid (", 
                        $value, "<", $threshold, ") @VALUE@", $value, "@ @EXPECTED@", $threshold, "@")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Geometric_Info//Planimetric_Stability/VALUE)
                     return
                     concat ("Planimetric stability is invalid (", 
                        $value, ">", $threshold, ") @VALUE@", $value, "@ @EXPECTED@", $threshold, "@")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Absolute_Location_Value">
               <name>Check the absolute Location value.</name>
               <thematic>GEOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="threshold">30</parameter>
               </queryParameters>
               <query><![CDATA[
                  
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Geometric_Info//Absolute_Location/VALUE)
                     return
                        $value < $threshold
                  
               ]]></query>
               <successMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Geometric_Info//Absolute_Location/VALUE)
                     return
                     concat ("Absolute location is valid (", 
                        $value, "<", $threshold, ") @VALUE@", $value, "@ @EXPECTED@", $threshold, "@")
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                     declare variable $threshold as xs:double* external;
                     let $value := xs:double(*[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Geometric_Info//Absolute_Location/VALUE)
                     return
                     concat ("Absolute location is invalid (", 
                        $value, ">", $threshold, ") @VALUE@", $value, "@ @EXPECTED@", $threshold, "@")
               
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="List_Fake_Decompressed_Source_Frames">
               <name>Check list of fake decompressed sources frames </name>
               <thematic>GENERAL_QUALITY</thematic>
               <query><![CDATA[
                  
                     let $fakes := *[matches(name(), ".*_DataStrip_ID")]/
                        Image_Data_Info/List_Fake_Decompr_Source_Frames
                     
                     (: 10m :)
                     let $list10m := (
                        for $fake at $position in $fakes
                           where
                           (
                              $position = 2 or
                              $position = 3 or
                              $position = 4 or
                              $position = 8
                           )
                           return
                              let $first  := fn:data($fake/FIRST)
                              let $number := fn:data($fake/NUMBER_SOURCE)
                              let $last   := $first + $number
                              return
                                 if (($first > 0 and $first <= 144) and 
                                     ($last  > 0 and $last  <= 144))
                                 then 0
                                 else 1
                     )
                     (: 20m :)
                     let $list20m := (
                        for $fake at $position in $fakes
                           where
                           (
                              $position = 5 or
                              $position = 6 or
                              $position = 7 or
                              $position = 9 or (: 8A :)
                              $position = 12 or
                              $position = 13
                              
                           )
                           return
                              let $first  := $fake/FIRST
                              let $number := $fake/NUMBER_SOURCE
                              let $last   := $first + $number
                              return
                                 if (($first > 0 and $first <= 72) and 
                                     ($last  > 0 and $last  <= 72))
                                 then 0
                                 else 1
                     )
                     (: 60m :)
                     let $list60m := ( 
                        for $fake at $position in $fakes
                           where
                           (
                              $position = 1 or
                              $position = 10 or
                              $position = 11
                           )
                           return
                              let $first  := xs:positiveInteger ($fake/FIRST)
                              let $number := xs:positiveInteger ($fake/NUMBER_SOURCE)
                              let $last   := $first + $number
                              return
                                 if (($first >= 0 and $first <= 24) and 
                                     ($last  >= 0 and $last  <= 24))
                                 then 0
                                 else 1
                     )
                     
                     let $ok10m := if (fn:empty ($list10m)) then fn:true() else (fn:sum ($list10m)=0)
                     let $ok20m := if (fn:empty ($list20m)) then fn:true() else (fn:sum ($list20m)=0) 
                     let $ok60m := if (fn:empty ($list60m)) then fn:true() else (fn:sum ($list60m)=0)
                     
                     return
                        $ok10m and $ok20m and $ok60m
                  
               ]]></query>
               <successMessage><![CDATA[
               
                  let $fakes := *[matches(name(), ".*_DataStrip_ID")]/
                        Image_Data_Info/List_Fake_Decompr_Source_Frames
                  return
                  concat ("Fake decompressed source frames are valid. ",
                   string-join ((  
                     for $fake at $position in $fakes
                     return
                        let $first  := xs:positiveInteger ($fake/FIRST)
                        let $number := xs:positiveInteger ($fake/NUMBER_SOURCE)
                        let $last   := $first + $number
                        return
                        concat ('@LAST(', $position, ')@', $last, '@')), ' ')
                  )
               
               ]]></successMessage>
               <failureMessage><![CDATA[
               
                  let $fakes := *[matches(name(), ".*_DataStrip_ID")]/
                        Image_Data_Info/List_Fake_Decompr_Source_Frames
                  return
                  concat ("Fake decompressed source frames are invalid. ",
                   string-join ((  
                     for $fake at $position in $fakes
                     return
                        let $first  := xs:positiveInteger ($fake/FIRST)
                        let $number := xs:positiveInteger ($fake/NUMBER_SOURCE)
                        let $last   := $first + $number
                        return
                        concat ('@LAST(', $position, ')@', $last, '@')), ' ')
                  )
               
               ]]></failureMessage>
            </xqueryInspection>
	    
            
            <xqueryInspection version="1.0"
               id="Radiometric_Quality_Indicators_Absolute">
               <name>Check on the Radiometric Quality Indicators : Absolute Calibration Accuracy.</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="max_accuracy">5</parameter>
               </queryParameters>
               <query><![CDATA[
                  declare variable $max_accuracy as xs:double* external;
                  let $error_bands := (
                     for $band in *[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Radiometric_Info/
                        Radiometric_Quality_List/Radiometric_Quality
                     where xs:double($band/ABSOLUTE_CALIBRATION_ACCURACY) > $max_accuracy
                     return $band
                  )
                  return fn:empty($error_bands)
               ]]></query>
               <successMessage><![CDATA[
                 "Absolute calibration accuracy is correct."
               ]]></successMessage>
               <failureMessage><![CDATA[
                 declare variable $max_accuracy as xs:double* external;
                 let $error_bands := (
                    for $band in *[matches(name(), ".*_DataStrip_ID")]/
                       Quality_Indicators_Info/Radiometric_Info/
                       Radiometric_Quality_List/Radiometric_Quality
                    where xs:double($band/ABSOLUTE_CALIBRATION_ACCURACY) > $max_accuracy
                    return 
                       concat ('@BAND(', $band/@bandId, ")@", $band/ABSOLUTE_CALIBRATION_ACCURACY, "@")
                  )
                  return
                     concat ("Absolute calibration accuracy exceeds the threshold.",
                        '@MAX_ACCURACY@', $max_accuracy, '@ ',
                        string-join($error_bands, " "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="Radiometric_Quality_Indicators_Cross_Band">
               <name>Check on the Radiometric Quality Indicators : Cross Band Calibration Accuracy.</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="max_accuracy">5</parameter>
               </queryParameters>
               <query><![CDATA[
                  declare variable $max_accuracy as xs:double* external;
                  let $error_bands := (
                     for $band in *[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Radiometric_Info/
                        Radiometric_Quality_List/Radiometric_Quality
                     where xs:double($band/CROSS_BAND_CALIBRATION_ACCURACY) > $max_accuracy
                     return $band
                  )
                  return fn:empty($error_bands)
               ]]></query>
               <successMessage><![CDATA[
                 "Cross band calibration accuracy is correct."
               ]]></successMessage>
               <failureMessage><![CDATA[
                 declare variable $max_accuracy as xs:double* external;
                 let $error_bands := (
                    for $band in *[matches(name(), ".*_DataStrip_ID")]/
                       Quality_Indicators_Info/Radiometric_Info/
                       Radiometric_Quality_List/Radiometric_Quality
                    where xs:double($band/CROSS_BAND_CALIBRATION_ACCURACY) > $max_accuracy
                    return 
                       concat ('@BAND(', $band/@bandId, ")@", $band/CROSS_BAND_CALIBRATION_ACCURACY, "@")
                  )
                  return
                     concat ("Cross band calibration accuracy exceeds the threshold.",
                        '@MAX_ACCURACY@', $max_accuracy, '@ ',
                        string-join($error_bands, " "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="Radiometric_Quality_Indicators_Multi_Temporal">
               <name>Check on the Radiometric Quality Indicators : Multi-Temporal Calibration Accuracy.</name>
               <thematic>RADIOMETRIC_QUALITY</thematic>
               <queryParameters>
                  <parameter name="max_accuracy">5</parameter>
               </queryParameters>
               <query><![CDATA[
                  declare variable $max_accuracy as xs:double* external;
                  let $error_bands := (
                     for $band in *[matches(name(), ".*_DataStrip_ID")]/
                        Quality_Indicators_Info/Radiometric_Info/
                        Radiometric_Quality_List/Radiometric_Quality
                     where xs:double($band/MULTI_TEMPORAL_CALIBRATION_ACCURACY) > $max_accuracy
                     return $band
                  )
                  return fn:empty($error_bands)
               ]]></query>
               <successMessage><![CDATA[
                 "Multi-temporal calibration accuracy is correct."
               ]]></successMessage>
               <failureMessage><![CDATA[
                 declare variable $max_accuracy as xs:double* external;
                 let $error_bands := (
                    for $band in *[matches(name(), ".*_DataStrip_ID")]/
                       Quality_Indicators_Info/Radiometric_Info/
                       Radiometric_Quality_List/Radiometric_Quality
                    where xs:double($band/MULTI_TEMPORAL_CALIBRATION_ACCURACY) > $max_accuracy
                    return 
                       concat ('@BAND(', $band/@bandId, ")@", $band/MULTI_TEMPORAL_CALIBRATION_ACCURACY, "@")
                  )
                  return
                     concat ("Multi-temporal calibration accuracy exceeds the threshold.",
                        '@MAX_ACCURACY@', $max_accuracy, '@ ',
                        fn:string-join($error_bands, " "))
               ]]></failureMessage>
            </xqueryInspection>

<!--
            <customJavaInspection
               class="fr.gael.olqc.inspection.impl.snr.SnrInspector" 
               classpath="snr/amalfi-config-sentinel-2-snr-inspector-15.0.0.jar"
               version="1.0" id="SNR" inspectorId="http://www.esa.int/s2#OlqcSnrInspector">
               <name>Computes SNR values </name>
               <thematic>IMAGE_QUALITY</thematic>
               <parameters>
                  <applicableRegions xmlns="http://SNR">
                     <region>
                        <name>Test Area for S20130707T172022_D01_N01 Granule</name>
                        <geometry>POLYGON((-100 28, -98 28, -98 27, -100 27, -100 28))</geometry>
                     </region>
                     <region>
                        <name>Test Area for T30TXN_N01 Tile</name>
                        <geometry>POLYGON((-2 44, 0 44, 0 42, -2 42, -2 44))
                        </geometry>
                     </region>
                     <region>
                        <name>earth</name>
                        <geometry>POLYGON((-180 90, 180 90, 180 -90, -180 -90, -180 90))</geometry>
                     </region>
                  </applicableRegions>
               </parameters>
            </customJavaInspection>
-->

            <customJavaInspection
               class="fr.gael.olqc.inspection.impl.jp2gml.Jp2GmlInspector" 
               classpath="jp2gml/amalfi-config-sentinel-2-jp2gml-inspector-15.0.0.jar"
               version="1.0" id="Jp2Gml" inspectorId="http://www.esa.int/s2#OlqcJp2GmlInspector">
               <name>Checks JP2GML boxes in images </name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <parameters>
                  <applicableRegions xmlns="http://SNR">
                     <region>
                        <name>earth</name>
                        <geometry>POLYGON((-180 90, 180 90, 180 -90, -180 -90, -180 90))</geometry>
                     </region>
                  </applicableRegions>
               </parameters>
            </customJavaInspection>

            <customJavaInspection
               class="fr.gael.olqc.inspection.impl.data_anomaly.DataAnomalyInspector"
               classpath="data_anomaly/amalfi-config-sentinel-2-data-anomaly-inspector-15.0.0.jar"
               version="1.0" id="Data_Anomaly" inspectorId="http://www.esa.int/s2#OlqcDataAnomalyInspector">
               <name>Check for discovering new possibly NO-DATA, SATURATED or  pixels.</name>
               <thematic>IMAGE_QUALITY</thematic>
               <parameters>
                  <applicableRegions xmlns="http://data_anomaly">
                     <region>
                        <name>earth</name>
                        <geometry>POLYGON((-180 90, 180 90, 180 -90, -180 -90, -180 90))
                        </geometry>
                     </region>

                  </applicableRegions>

                  <masks xmlns="http://data_anomaly">
                     <mask>
                        <typeName>
                           MSK_SATURA
                        </typeName>
                        <bands>
                           <band>B01</band>
                           <band>B02</band>
                           <band>B03</band>
                           <band>B04</band>
                           <band>B05</band>
                           <band>B06</band>
                           <band>B07</band>
                           <band>B08</band>
                           <band>B8A</band>
                           <band>B09</band>
                           <band>B10</band>
                           <band>B11</band>
                           <band>B12</band>
                        </bands>
                        <subType>
                           <name>
                              QT_SATURATED_PIXELS_L1B
                           </name>
                           <value>65535</value>
                        </subType>
                     </mask>
                     <mask>
                        <typeName>
                           MSK_DEFECT
                        </typeName>
                        <bands>
                           <band>B01</band>
                           <band>B02</band>
                           <band>B03</band>
                           <band>B04</band>
                           <band>B05</band>
                           <band>B06</band>
                           <band>B07</band>
                           <band>B08</band>
                           <band>B8A</band>
                           <band>B09</band>
                           <band>B10</band>
                           <band>B11</band>
                           <band>B12</band>
                        </bands>
                        <subType>
                           <name>
                              QT_DEFECTIVE_PIXELS
                           </name>
                           <value>0</value>
                        </subType>
                     </mask>
                     <mask>
                        <typeName>
                           MSK_NODATA
                        </typeName>
                        <bands>
                           <band>B01</band>
                           <band>B02</band>
                           <band>B03</band>
                           <band>B04</band>
                           <band>B05</band>
                           <band>B06</band>
                           <band>B07</band>
                           <band>B08</band>
                           <band>B8A</band>
                           <band>B09</band>
                           <band>B10</band>
                           <band>B11</band>
                           <band>B12</band>
                        </bands>
                        <subType>
                           <name>
                              QT_NODATA_PIXELS
                           </name>
                           <value>0</value>
                        </subType>
                     </mask>
                  </masks>
               </parameters>
            </customJavaInspection>

            <xqueryInspection version="1.0"
               id="Tile_Position_Geoposition">
               <name>Check of consistency of Tile Position by Geoposition.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <queryParameters>
                  <parameter name="max_x">900000.0</parameter>
                  <parameter name="min_x">99900.0</parameter>
                  <parameter name="max_y">20000000.0</parameter>
                  <parameter name="min_y">0.0</parameter>
               </queryParameters>
               <query><![CDATA[
               
                  declare variable $max_y as xs:double* external;
                  declare variable $min_y as xs:double* external;

                  declare variable $max_x as xs:double* external;
                  declare variable $min_x as xs:double* external;
                  
                  (: projection is always considered as UTM so unit is always metre :)
                  let $res_10m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=10]
                  let $ulx_10m := $res_10m/ULX
                  let $uly_10m := $res_10m/ULY
                  let $xdim_10m := $res_10m/XDIM
                  let $ydim_10m := $res_10m/YDIM
                     
                  let $res_20m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=20]
                  let $ulx_20m := $res_20m/ULX
                  let $uly_20m := $res_20m/ULY
                  let $xdim_20m := $res_20m/XDIM
                  let $ydim_20m := $res_20m/YDIM
                    
                  let $res_60m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=60]
                  let $ulx_60m := $res_60m/ULX
                  let $uly_60m := $res_60m/ULY
                  let $xdim_60m := $res_60m/XDIM
                  let $ydim_60m := $res_60m/YDIM
                 
                  return
                     xs:double($ulx_10m) < $max_x and
                     xs:double($ulx_10m) > $min_x and
                     xs:double($uly_10m) < $max_y and
                     xs:double($uly_10m) > $min_y and
                     xs:double($xdim_10m)=10.0    and
                     xs:double($ydim_10m)=-10.0   and
                     xs:double($ulx_20m) < $max_x and
                     xs:double($ulx_20m) > $min_x and
                     xs:double($uly_20m) < $max_y and
                     xs:double($uly_20m) > $min_y and
                     xs:double($xdim_20m)=20.0    and
                     xs:double($ydim_20m)=-20.0   and
                     xs:double($ulx_60m) < $max_x and
                     xs:double($ulx_60m) > $min_x and
                     xs:double($uly_60m) < $max_y and
                     xs:double($uly_60m) > $min_y and
                     xs:double($xdim_60m)=60.0    and
                     xs:double($ydim_60m)=-60.0
                 
               ]]></query>
               <successMessage><![CDATA[
                  let $res_10m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=10]
                  let $ulx_10m := $res_10m/ULX
                  let $uly_10m := $res_10m/ULY
                  let $xdim_10m := $res_10m/XDIM
                  let $ydim_10m := $res_10m/YDIM
                     
                  let $res_20m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=20]
                  let $ulx_20m := $res_20m/ULX
                  let $uly_20m := $res_20m/ULY
                  let $xdim_20m := $res_20m/XDIM
                  let $ydim_20m := $res_20m/YDIM
                    
                  let $res_60m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=60]
                  let $ulx_60m := $res_60m/ULX
                  let $uly_60m := $res_60m/ULY
                  let $xdim_60m := $res_60m/XDIM
                  let $ydim_60m := $res_60m/YDIM
                 
                  return
                     concat ("Tile geoposition is valid.",
                        '@ULX(10)@', $ulx_10m , '@ ',
                        '@ULY(10)@', $uly_10m , '@ ',
                        '@XDIM(10)@', $xdim_10m , '@ ',
                        '@YDIM(10)@', $ydim_10m , '@ ',
                        '@ULX(20)@', $ulx_20m , '@ ',
                        '@ULY(20)@', $uly_20m , '@ ',
                        '@XDIM(20)@', $xdim_20m , '@ ',
                        '@YDIM(20)@', $ydim_20m , '@ ',
                        '@ULX(60)@', $ulx_60m , '@ ',
                        '@ULY(60)@', $uly_60m , '@ ',
                        '@XDIM(60)@', $xdim_60m , '@ ',
                        '@YDIM(60)@', $ydim_60m , '@')
               ]]></successMessage>
               <failureMessage><![CDATA[
                  declare variable $max_y as xs:double* external;
                  declare variable $min_y as xs:double* external;
                  declare variable $max_x as xs:double* external;
                  declare variable $min_x as xs:double* external;
                  
                  let $res_10m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=10]
                  let $ulx_10m := $res_10m/ULX
                  let $uly_10m := $res_10m/ULY
                  let $xdim_10m := $res_10m/XDIM
                  let $ydim_10m := $res_10m/YDIM
                     
                  let $res_20m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=20]
                  let $ulx_20m := $res_20m/ULX
                  let $uly_20m := $res_20m/ULY
                  let $xdim_20m := $res_20m/XDIM
                  let $ydim_20m := $res_20m/YDIM
                    
                  let $res_60m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=60]
                  let $ulx_60m := $res_60m/ULX
                  let $uly_60m := $res_60m/ULY
                  let $xdim_60m := $res_60m/XDIM
                  let $ydim_60m := $res_60m/YDIM
                 
                  return
                  concat ("Tile geopisition is invalid.",
                     '@MAX_Y@', $max_y, '@ ',
                     '@MIN_Y@', $min_y, '@ ',
                     '@MAX_X@', $max_x, '@ ',
                     '@MIN_X@', $min_x, '@ ',
                     '@ULX(10)@', $ulx_10m , '@ ',
                     '@ULY(10)@', $uly_10m , '@ ',
                     '@XDIM(10)@', $xdim_10m , '@ ',
                     '@YDIM(10)@', $ydim_10m , '@ ',
                     '@ULX(20)@', $ulx_20m , '@ ',
                     '@ULY(20)@', $uly_20m , '@ ',
                     '@XDIM(20)@', $xdim_20m , '@ ',
                     '@YDIM(20)@', $ydim_20m , '@ ',
                     '@ULX(60)@', $ulx_60m , '@ ',
                     '@ULY(60)@', $uly_60m , '@ ',
                     '@XDIM(60)@', $xdim_60m , '@ ',
                     '@YDIM(60)@', $ydim_60m , '@')
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Tile_Position_Size">
               <name>Check of consistency of Tile Position by Size.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <queryParameters>
                  <parameter name="epsilon">10000.0</parameter>
               </queryParameters>
               <query><![CDATA[
                  declare variable $epsilon as xs:double* external;
                  (: math:abs sometimes unexpectedly returns NaN :)
                  declare function local:abs ($value)
                  {
                     let $v := xs:double ($value)
                     return
                        if ($v<0) then $v*-1
                        else $v
                  };
                  
                  let $size_10m := *[matches(name(),"Level-.._Tile_ID")]/
                     Geometric_Info/Tile_Geocoding/Size[@resolution="10"]
                     
                  let $xdim_10m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=10]/XDIM
                  let $ydim_10m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=10]/YDIM
                  
                  let $image_width_10m  := local:abs(xs:double($ydim_10m)*xs:double($size_10m/NCOLS))   
                  let $image_height_10m := local:abs(xs:double($xdim_10m)*xs:double($size_10m/NROWS)) 

                  let $size_20m := *[matches(name(),"Level-.._Tile_ID")]/
                     Geometric_Info/Tile_Geocoding/Size[@resolution="20"]
                     
                  let $xdim_20m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=20]/XDIM
                  let $ydim_20m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=20]/YDIM
                  
                  let $image_width_20m  := local:abs(xs:double($ydim_20m)*xs:double($size_20m/NCOLS))   
                  let $image_height_20m := local:abs(xs:double($xdim_20m)*xs:double($size_20m/NROWS)) 

                  let $size_60m := *[matches(name(),"Level-.._Tile_ID")]/
                     Geometric_Info/Tile_Geocoding/Size[@resolution="60"]
                     
                  let $xdim_60m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=60]/XDIM
                  let $ydim_60m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=60]/YDIM
                  
                  let $image_width_60m  := local:abs(xs:double($ydim_60m)*xs:double($size_60m/NCOLS))   
                  let $image_height_60m := local:abs(xs:double($xdim_60m)*xs:double($size_60m/NROWS)) 
                  
                  return
                     $image_width_10m >= (100000.0-$epsilon)  and
                     $image_width_10m <  (100000.0+$epsilon)  and
                     $image_height_10m >= (100000.0-$epsilon) and
                     $image_height_10m <  (100000.0+$epsilon) and
                     $image_width_20m >= (100000.0-$epsilon)  and
                     $image_width_20m <  (100000.0+$epsilon)  and
                     $image_height_20m >= (100000.0-$epsilon) and
                     $image_height_20m <  (100000.0+$epsilon) and
                     $image_width_60m >= (100000.0-$epsilon)  and
                     $image_width_60m <  (100000.0+$epsilon)  and
                     $image_height_60m >= (100000.0-$epsilon) and
                     $image_height_60m <  (100000.0+$epsilon)
               
               ]]></query>
               <successMessage><![CDATA[
                 declare variable $epsilon as xs:double* external;
                 concat ('Tile image size is between [', 
                    (100000-$epsilon), ',', (100000+$epsilon), '].')
               ]]></successMessage>
               <failureMessage><![CDATA[
                 declare variable $epsilon as xs:double* external;
                 (: math:abs sometimes unexpectedly returns NaN :)
                 declare function local:abs ($value)
                 {
                    let $v := xs:double ($value)
                    return
                       if ($v<0) then $v*-1
                       else $v
                 };
                 
                 let $size_10m := *[matches(name(),"Level-.._Tile_ID")]/
                     Geometric_Info/Tile_Geocoding/Size[@resolution="10"]
                     
                  let $xdim_10m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=10]/XDIM
                  let $ydim_10m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=10]/YDIM
                  
                  let $image_width_10m  := local:abs(xs:double($ydim_10m)*xs:double($size_10m/NCOLS))   
                  let $image_height_10m := local:abs(xs:double($xdim_10m)*xs:double($size_10m/NROWS))
                  
                  let $size_20m := *[matches(name(),"Level-.._Tile_ID")]/
                     Geometric_Info/Tile_Geocoding/Size[@resolution="20"]
                     
                  let $xdim_20m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=20]/XDIM
                  let $ydim_20m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=20]/YDIM
                  
                  let $image_width_20m  := local:abs(xs:double($ydim_20m)*xs:double($size_20m/NCOLS))   
                  let $image_height_20m := local:abs(xs:double($xdim_20m)*xs:double($size_20m/NROWS)) 

                  let $size_60m := *[matches(name(),"Level-.._Tile_ID")]/
                     Geometric_Info/Tile_Geocoding/Size[@resolution="60"]
                     
                  let $xdim_60m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=60]/XDIM
                  let $ydim_60m := *[matches(name(),"Level-.._Tile_ID")]/Geometric_Info/
                     Tile_Geocoding/Geoposition[@resolution=60]/YDIM
                  
                  let $image_width_60m  := local:abs(xs:double($ydim_60m)*xs:double($size_60m/NCOLS))   
                  let $image_height_60m := local:abs(xs:double($xdim_60m)*xs:double($size_60m/NROWS)) 
                  
                  return
                    concat ('Tile image size is greater than range [', 
                       (100000-$epsilon), ',', (100000+$epsilon), '].',
                       '@EPSILON@', $epsilon, '@ ',
                       '@WIDTH(10)@', $image_width_10m, '@ ',
                       '@HEIGHT(10)@', $image_height_10m, '@ ',
                       '@WIDTH(20)@', $image_width_20m, '@ ',
                       '@HEIGHT(20)@', $image_height_20m, '@ ',
                       '@WIDTH(60)@', $image_width_60m, '@ ',
                       '@HEIGHT(60)@', $image_height_60m, '@ ')
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="PVI_and_TCI">
               <name>Check of consistency of PVI </name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                    let $pvi_file := QI_DATA/*[matches (name(), "(.*_PVI\.jp2|S2[A-D]_OPER_PVI.*\.jp2)")]
                    return
                       not (fn:empty ($pvi_file)) and
                       $pvi_file[1]/@size > 0
               ]]></query>
               <successMessage><![CDATA[
                  "PVI file is consistent."
               ]]></successMessage>
               <failureMessage><![CDATA[
                  "PVI files are empty or missing."
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Ecmwf">
               <name>ECMWF data conformity and completeness check </name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                    AUX_DATA/*[matches (name (), "(AUX_ECMWFT|S2[A-D]_OPER_AUX_ECMWF.*)")]
               ]]></query>
               <successMessage><![CDATA[
                 "ECMWF file is present."
               ]]></successMessage>
               <failureMessage><![CDATA[
                 "ECMWF file is missing."
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="Aux_Cams">
               <name>AUX_CAMS data conformity and completeness check </name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                    let $aux_cams := AUX_DATA/*[matches (name(), "(AUX_CAMS.*|S2[A-D]_OPER_AUX_CAMS.*)")]
                    return
                       not (fn:empty ($aux_cams)) and
                       $aux_cams[1]/@size > 0
               ]]></query>
               <successMessage><![CDATA[
                 "AUX_CAMS file is present."
               ]]></successMessage>
               <failureMessage><![CDATA[
                 "AUX_CAMS file is empty or missing."
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="acquisitionPeriodExists">
               <name>Checks if Acquisition Period is present.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     fn:not(empty(*[matches (name(),"(?i)manifest.safe")]/XFDU/
                        metadataSection/metadataObject[@ID="acquisitionPeriod"]))
                  
               ]]></query>
               <successMessage><![CDATA[
                  "Acquisition Period exists."
               ]]></successMessage>
               <failureMessage><![CDATA[
                  "Acquisition Period mandatory metadata is not present."
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="processingExists">
               <name>Checks if Processing metadata is present.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     fn:not(empty(*[matches (name(),"(?i)manifest.safe")]/XFDU/
                        metadataSection/metadataObject[@ID="processing"]))
                  
               ]]></query>
               <successMessage><![CDATA[
                  "Processing exists."
               ]]></successMessage>
               <failureMessage><![CDATA[
                  "Processing mandatory metadata is not present."
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="acquisitionPeriodCategory">
               <name>Checks if Acquisition Period Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     "DMD" = (*[matches (name(),"(?i)manifest.safe")]/XFDU/
                        metadataSection/metadataObject[@ID="acquisitionPeriod"]/@category)
                  
               ]]></query>
               <successMessage><![CDATA[
                  "Acquisition Period Category is Ok."
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
                  concat("Acquisition Period Category is ", (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/metadataObject[
                     @ID="acquisitionPeriod"]/@category), " instead of DMD.")
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="acquisitionPeriodClassification">
               <name>Checks if Acquisition Period Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     "DESCRIPTION" = (*[matches (name(),"(?i)manifest.safe")]/XFDU/
                        metadataSection/metadataObject[@ID="acquisitionPeriod"]/@classification)
                  
               ]]></query>
               <successMessage><![CDATA[
                  "Acquisition Period Classification is Ok."
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
                  concat("Acquisition Period Classification is ",(*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/metadataObject[
                     @ID="acquisitionPeriod"]/@classification)," instead of DESCRIPTION.")
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="processingCategory">
               <name>Checks if Processing Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     "PDI" = (*[matches (name(),"(?i)manifest.safe")]/XFDU/
                        metadataSection/metadataObject[@ID="processing"]/@category)
                  
               ]]></query>
               <successMessage><![CDATA[
                  "Processing Category is Ok."
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
                  fn:concat("Processing Category is ",(*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/metadataObject[
                     @ID="processing"]/@category)," instead of PDI.")
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="processingClassification">
               <name>Checks if Processing Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     "PROVENANCE" = (*[matches (name(),"(?i)manifest.safe")]/XFDU/
                        metadataSection/metadataObject[@ID="processing"]/@classification)
                  
               ]]></query>
               <successMessage><![CDATA[
                  "Processing Classification is Ok."
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
                  fn:concat("Processing Classification is ",(*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/metadataObject[
                     @ID="processing"]/@classification)," instead of PROVENANCE.")
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="platformCategory">
               <name>Checks if Platform Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     "DMD" = (*[matches (name(),"(?i)manifest.safe")]/XFDU/
                        metadataSection/metadataObject[@ID="platform"]/@category)
                  
               ]]></query>
               <successMessage><![CDATA[
                  "Platform Category is Ok."
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
                  fn:concat("Platform Category is ",(*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/metadataObject[
                     @ID="platform"]/@category)," instead of DMD.")
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="platformClassification">
               <name>Checks if Platform Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                     "DESCRIPTION" = (*[matches (name(),"(?i)manifest.safe")]/XFDU/
                        metadataSection/metadataObject[@ID="platform"]/@classification)
                  
               ]]></query>
               <successMessage><![CDATA[
                  "Platform Classification is Ok."
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
                  fn:concat("Platform Classification is ",(*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/metadataObject[
                     @ID="platform"]/@classification)," instead of DESCRIPTION.")
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="schemaCategory">
               <name>Checks if Schema Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*Schema")                  
                            return "true"
                            
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*Schema")                     
                            return $mds/@category = "REP"
                            
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*Schema")            
                         return $mds/@ID
                         
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Category ok for : ", string-join($result, ", "))
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*Schema") and not(matches($mds/@category,"REP"))
                         return $mds/@ID
               
               return concat("Category not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="schemaClassification">
               <name>Checks if Schema Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*Schema")                  
                            return "true"
                            
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*Schema")                     
                            return $mds/@classification = "SYNTAX"
                            
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*Schema")                   
                         return $mds/@ID
                         
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Classification ok for : ", string-join($result, ", "))    
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*Schema") and not(matches($mds/@classification, 
                           "SYNTAX"))
                           return $mds/@ID
                        
               return concat("Classification not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="annotationCategory">
               <name>Checks if Annotation Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*Annotation")                  
                            return "true"
                            
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*Annotation")                     
                            return $mds/@category = "DMD"
               
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*Annotation")            
                        return $mds/@ID
                        
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Category ok for : ", string-join($result, ", "))
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*Annotation") and not(matches($mds/@category,"DMD"))
                        return $mds/@ID
                        
               return concat("Category not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="annotationClassification">
               <name>Checks if Annotation Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*Annotation")                  
                            return "true"
                            
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*Annotation")                     
                            return $mds/@classification = "DESCRIPTION"
                            
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*Annotation")                   
                         return $mds/@ID
                         
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Classification ok for : ", string-join($result, ", "))    
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*Annotation") and not(matches($mds/@classification, 
                           "DESCRIPTION"))
                           return $mds/@ID
               
               return concat("Classification not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="frameSetCategory">
               <name>Checks if MeasurementFrameSet Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*FrameSet")                  
                            return "true"
                            
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*FrameSet")                     
                            return $mds/@category = "DMD"
                            
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*FrameSet")            
                        return $mds/@ID
                        
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Category ok for : ", string-join($result, ", "))
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*FrameSet") and not(matches($mds/@category,"DMD"))
                        return $mds/@ID
                        
               return concat("Category not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="frameSetClassification">
               <name>Checks if MeasurementFrameSet Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*FrameSet")                  
                           return "true"
                        
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*FrameSet")                     
                           return $mds/@classification = "DESCRIPTION"
               
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*FrameSet")                   
                        return $mds/@ID
                        
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Classification ok for : ", string-join($result, ", "))    
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*FrameSet") and not(matches($mds/@classification, 
                           "DESCRIPTION"))
                           return $mds/@ID
               
               return concat("Classification not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="gridReferenceCategory">
               <name>Checks if Grid Reference Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*GridReference")                  
                            return "true"
                            
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*GridReference")                     
                            return $mds/@category = "DMD"
                            
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*GridReference")            
                        return $mds/@ID
                        
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Category ok for : ", string-join($result, ", "))
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*GridReference") and not(matches($mds/@category,"DMD"))
                        return $mds/@ID
                        
               return concat("Category not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="gridReferenceClassification">
               <name>Checks if Grid Reference Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*GridReference")                  
                           return "true"
                           
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*GridReference")                     
                           return $mds/@classification = "DESCRIPTION"
                           
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*GridReference")                   
                        return $mds/@ID
                        
               return if (count($result) = 0)
                     then "No Index classification in product."
                  else concat("Classification ok for : ", string-join($result, ", "))    
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*GridReference") and not(matches($mds/@classification, 
                           "DESCRIPTION"))
                            return $mds/@ID
                            
               return concat("Classification not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="indexCategory">
               <name>Checks if Index Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*Index")                  
                           return "true"
                           
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*Index")                     
                           return $mds/@category = "DMD"
                           
               return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*Index")            
                        return $mds/@ID
               
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Category ok for : ", string-join($result, ", "))
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*Index") and not(matches($mds/@category,"DMD"))
                        return $mds/@ID
                        
               return concat("Category not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="indexClassification">
               <name>Checks if Index Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*Index")                  
                           return "true"
                           
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*Index")                     
                           return $mds/@classification = "DESCRIPTION"
               
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*Index")                   
                        return $mds/@ID
               
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Classification ok for : ", string-join($result, ", "))    
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*Index") and not(matches($mds/@classification, 
                           "DESCRIPTION"))
                           return $mds/@ID
                           
               return concat("Classification not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="informationCategory">
               <name>Checks if Information Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*Information")                  
                           return "true"
                           
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*Information")                     
                            return $mds/@category = "DMD"
                            
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*Information")            
                        return $mds/@ID
                        
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Category ok for : ", string-join($result, ", "))
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*Information") and not(matches($mds/@category,"DMD"))
                        return $mds/@ID
                        
               return concat("Category not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="informationClassification">
               <name>Checks if Information Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*Information")                  
                            return "true"
                            
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*Information")                     
                           return $mds/@classification = "DESCRIPTION"
               
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*Information")                   
                        return $mds/@ID
                        
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Classification ok for : ", string-join($result, ", "))    
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*Information") and not(matches($mds/@classification, 
                           "DESCRIPTION"))
                            return $mds/@ID
                            
               return concat("Classification not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="orbitReferenceCategory">
               <name>Checks if Orbit Reference Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*OrbitReference")                  
                           return "true"
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*OrbitReference")                     
                           return $mds/@category = "DMD"
                           
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*OrbitReference")            
                        return $mds/@ID
               
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Category ok for : ", string-join($result, ", "))
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*OrbitReference") and not(matches($mds/@category,"DMD"))
                        return $mds/@ID
                        
               return concat("Category not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="orbitReferenceClassification">
               <name>Checks if Orbit Reference Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*OrbitReference")                  
                           return "true"
                           
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*OrbitReference")                     
                           return $mds/@classification = "DESCRIPTION"
                           
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*OrbitReference")                   
                        return $mds/@ID
                        
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Classification ok for : ", string-join($result, ", "))    
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*OrbitReference") and not(matches($mds/@classification, 
                           "DESCRIPTION"))
                           return $mds/@ID
                           
               return concat("Classification not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="qualityInformationCategory">
               <name>Checks if Quality Information Category is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*QualityInformation")                  
                           return "true"
                           
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*QualityInformation")                     
                           return $mds/@category = "DMD"
                           
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*QualityInformation")            
                        return $mds/@ID
                        
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Category ok for : ", string-join($result, ", "))
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*QualityInformation") and not(matches($mds/@category,
                           "DMD"))
                           return $mds/@ID
                        
               return concat("Category not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0"
               id="qualityInformationClassification">
               <name>Checks if Quality Information Classification is correctly defined.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $check := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                           where matches($mds/@ID,".*QualityInformation")                  
                           return "true"
                           
                  let $result := for $mds in (*[matches (name(),
                        "(?i)manifest.safe")]/XFDU/metadataSection/*)
                           where matches($mds/@ID,".*QualityInformation")                     
                            return $mds/@classification = "DESCRIPTION"
                            
                  return count($result) = 0 or $result = $check
                  
               ]]></query>
               <successMessage><![CDATA[
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)      
                        where matches($mds/@ID,".*QualityInformation")                   
                        return $mds/@ID
               
               return if (count($result) = 0)
                  then "No Index classification in product."
                  else concat("Classification ok for : ", string-join($result, ", "))    
               ]]></successMessage>
               <failureMessage><![CDATA[
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
               let $result := for $mds in (*[matches (name(),
                     "(?i)manifest.safe")]/XFDU/metadataSection/*)   
                        where matches($mds/@ID,".*QualityInformation") and 
                           not(matches($mds/@classification, "DESCRIPTION"))
                           return $mds/@ID
               
               return concat("Classification not ok for : ", string-join($result, ", "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="idReferences">
               <name>Checks if all the Id References defined in the product are valid.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                  
                  declare function local:insertUniq ($sequence, $values)
                 {
                    let $value := for $val at $index in $values where $index = 1 return $val
                    let $others := for $val at $index in $values where $index != 1 return $val
            
                    let $newseq := (
                       for $iseq in $sequence where ($iseq < $value) return $iseq ,
                          $value,
                          for $iseq in $sequence where ($iseq > $value) return $iseq )
            
                    return
                       if (count($others) > 0)
                          then
                             local:insertUniq($newseq,$others)
                          else
                             $newseq
                 };
            
                 declare function local:sort($values)
                 {
                    local:insertUniq((),$values)
                 };
                 
                 if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $refs := (
                       let $nodes := manifest.safe/XFDU/informationPackageMap/contentUnit/contentUnit/@repID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $contentUnitrepID := local:sort ($refs)
                 let $checkcontentUnitrepID := for $ref in $contentUnitrepID 
                    return "false"              
                 let $resultcontentUnitrepID := for $ref in $contentUnitrepID
                    return empty (manifest.safe/XFDU/metadataSection/metadataObject/@ID[matches(data(.), data($ref))])

                let $refs1 := (
                       let $nodes := manifest.safe/XFDU/dataObjectSection/dataObject/@repID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $dataObjectrepID := local:sort ($refs1)
                 let $checkdataObjectrepID := for $ref in $dataObjectrepID 
                    return "false"              
                 let $resultdataObjectrepID := for $ref in $dataObjectrepID
                    return empty (manifest.safe/XFDU/metadataSection/metadataObject/@ID[matches(data(.), data($ref))])                 
                        
                let $refs2 := (
                       let $nodes := manifest.safe/XFDU/informationPackageMap/contentUnit//@dmdID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $dmdID := local:sort ($refs2)
                 let $checkdmdID := for $ref in $dmdID 
                    return "false"              
                 let $resultdmdID := for $ref in $dmdID
                    return empty (manifest.safe/XFDU/metadataSection//@ID[matches(data(.), data($ref))])                 
                             
                let $refs3 := (
                       let $nodes := manifest.safe/XFDU/informationPackageMap/contentUnit//@pdiID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $pdiID := local:sort ($refs3)
                 let $checkpdiID := for $ref in $pdiID 
                    return "false"              
                 let $resultpdiID := for $ref in $pdiID
                    return empty (manifest.safe/XFDU/metadataSection//@ID[matches(data(.), data($ref))])                 
                             
                let $refs4 := (
                       let $nodes := manifest.safe/XFDU/informationPackageMap/contentUnit//@dataObjectID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $dataObjectID := local:sort ($refs4)
                 let $checkpdataObjectID := for $ref in $dataObjectID 
                    return "false"              
                 let $resultdataObjectID := for $ref in $dataObjectID
                    return empty (manifest.safe/XFDU/dataObjectSection/dataObject/@ID[matches(data(.), data($ref))])                 
                        
                 return $resultcontentUnitrepID = $checkcontentUnitrepID and 
                    $resultdataObjectrepID = $checkdataObjectrepID and
                    $resultdmdID = $checkdmdID and $resultpdiID = $checkpdiID and
                    $resultdataObjectID = $checkpdataObjectID
                  
               ]]></query>
               <successMessage><![CDATA[
               "All the Id References defined in the product are valid."                 
               ]]></successMessage>
               <failureMessage><![CDATA[
                  
                  declare function local:insertUniq ($sequence, $values)
                 {
                    let $value := for $val at $index in $values where $index = 1 return $val
                    let $others := for $val at $index in $values where $index != 1 return $val
            
                    let $newseq := (
                       for $iseq in $sequence where ($iseq < $value) return $iseq ,
                          $value,
                          for $iseq in $sequence where ($iseq > $value) return $iseq )
            
                    return
                       if (count($others) > 0)
                          then
                             local:insertUniq($newseq,$others)
                          else
                             $newseq
                 };
            
                 declare function local:sort($values)
                 {
                    local:insertUniq((),$values)
                 };
                 if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else
                 let $refs := (
                       let $nodes := manifest.safe/XFDU/informationPackageMap/contentUnit/contentUnit/@repID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $contentUnitrepID := local:sort ($refs)           
                 let $resultcontentUnitrepID := for $ref in $contentUnitrepID
                    where empty (manifest.safe/XFDU/metadataSection/metadataObject/@ID[matches(data(.), data($ref))])
                       return $ref

                let $refs1 := (
                       let $nodes := manifest.safe/XFDU/dataObjectSection/dataObject/@repID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $dataObjectrepID := local:sort ($refs1)        
                 let $resultdataObjectrepID := for $ref in $dataObjectrepID
                    where empty (manifest.safe/XFDU/metadataSection/metadataObject/@ID[matches(data(.), data($ref))])                 
                     return $ref
                        
                let $refs2 := (
                       let $nodes := manifest.safe/XFDU/informationPackageMap/contentUnit//@dmdID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $dmdID := local:sort ($refs2)
                 let $resultdmdID := for $ref in $dmdID
                    where empty (manifest.safe/XFDU/metadataSection//@ID[matches(data(.), data($ref))])                 
                     return $ref
                             
                let $refs3 := (
                       let $nodes := manifest.safe/XFDU/informationPackageMap/contentUnit//@pdiID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $pdiID := local:sort ($refs3)        
                 let $resultpdiID := for $ref in $pdiID
                    where empty (manifest.safe/XFDU/metadataSection//@ID[matches(data(.), data($ref))])                 
                  return $ref
                          
                let $refs4 := (
                       let $nodes := manifest.safe/XFDU/informationPackageMap/contentUnit//@dataObjectID
                       for $idnames in $nodes
                          return
                              let $tokenized_refs := tokenize (data($idnames), " ") 
                              for $ref in $tokenized_refs
                              return $ref
                 )
                 let $dataObjectID := local:sort ($refs4)
                 let $resultdataObjectID := for $ref in $dataObjectID
                    where empty (manifest.safe/XFDU/dataObjectSection/dataObject/@ID[matches(data(.), data($ref))])
                       return $ref  
                 let $count := count($resultcontentUnitrepID)+
                               count($resultdataObjectID)    +
                               count($resultdmdID)           +
                               count($resultdataObjectrepID) +
                               count($resultpdiID)
                 return
                 if ($count = 0)
                 then
                    "No ID used in this manifest."
                 else              
                    concat($count," id References defined in the product are not valid : ", 
                       string-join($resultcontentUnitrepID," ")," ", string-join($resultdmdID," ")," ", 
                       string-join($resultdataObjectrepID," ")," ",  string-join($resultpdiID," ")," ", 
                       string-join($resultdataObjectID," "))
                    
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="extraData">
               <name>Checks if Extra Files are present in product directory.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                                 
                 if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $allfiles := *
                 let $result := for $file in $allfiles
                    return
                       let $ref := manifest.safe/XFDU/metadataSection/metadataObject/metadataReference/@*[name()="href" and data(.)=name($file)]                      
                         return empty($ref) and name($file) != name(.) and $file/@directory=false   
               
                 let $check := for $file in $allfiles
                   return "false"
                      
                 return $check = $result                
                  
               ]]></query>
               <successMessage><![CDATA[  
                  "No Extra Files found in product directory."
               ]]></successMessage>
               <failureMessage><![CDATA[
                 if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else              
                  let $allfiles := *
                  let $result := for $file in $allfiles
                     where empty(manifest.safe/XFDU/metadataSection/metadataObject/metadataReference/@*[name()="href" and data(.)=name($file)]) and 
                   name($file) != name(.) and $file/@directory=false
                      return name($file)
                      
                  return concat(count($result)," extra Files found in product directory : ", string-join($result, " "))
               ]]></failureMessage>
            </xqueryInspection>
            <xqueryInspection version="1.0" id="hrefExist">
               <name>Checks if all external references are present in the product directory.</name>
               <thematic>FORMAT_CORRECTNESS</thematic>
               <query><![CDATA[
                                 
                 declare function local:findHref ($dir, $path) as xs:boolean?
                {               
                   let $tok := for $token in $path where $token != '.' return $token
                   let $tk := $tok[1]
                   let $follow := for $val at $index in $tok where $index != 1 return $val
                      return
                         if (exists ($tk))
                            then
                               let $ret := $dir/*[name()=$tk]
                                  return
                                     if ($ret) 
                                        then 
                                           local:findHref ($ret, $follow)
                                        else
                                           xs:boolean ("false")
                            else
                               xs:boolean ("true")
                }; 
               
                if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     fn:false()
                  else
                  let $allhref := manifest.safe/XFDU/metadataSection/metadataObject/metadataReference/@href
                     let $allhref2 := manifest.safe/XFDU/dataObjectSection/dataObject/byteStream/fileLocation/@href                  
                  
                let $check := for $href in $allhref
                   return "true"
                  
                let $result := for $href in $allhref               
                   return local:findHref(., tokenize($href, "/"))
                   
                let $check2 := for $href in $allhref2
                   return "true"
                  
                let $result2 := for $href in $allhref2         
                   return local:findHref(., tokenize($href, "/"))
                              
                return $check = $result and $check2 = $result2
                  
               ]]></query>
               <successMessage><![CDATA[
                  "All external references are present in the product directory."
               ]]></successMessage>
               <failureMessage><![CDATA[            
               declare function local:findHref ($dir, $path) as xs:boolean?
               {               
                let $tok := for $token in $path where $token != '.' return $token
                let $tk := $tok[1]
                let $follow := for $val at $index in $tok where $index != 1 return $val
                   return
                      if (exists ($tk))
                         then
                             let $ret := $dir/*[name()=$tk]
                               return
                                  if ($ret) 
                                     then 
                                        local:findHref ($ret, $follow)
                                     else
                                         xs:boolean ("false")
                         else
                             xs:boolean ("true")
              }; 
               if (empty(*[matches (name(),
                        "(?i)manifest.safe")]/XFDU))
                  then
                     "Manifest is not present or empty"
                  else              
               let $allhref := manifest.safe/XFDU/metadataSection/metadataObject/metadataReference/@href
                  let $allhref2 := manifest.safe/XFDU/dataObjectSection/dataObject/byteStream/fileLocation/@href                  
                                
              let $result := for $href in $allhref
                 where local:findHref(., tokenize($href, "/")) = "false"   
                   return $href
                   
              let $result2 := for $href in $allhref2
                 where local:findHref(., tokenize($href, "/")) = "false"   
                   return $href
                              
               return 
                  concat((count($result)+count($result2))," external references are missing in the product directory : ",
                   string-join($result, " ")," ", string-join($result2, " "))
               ]]></failureMessage>
            </xqueryInspection>
         </inspections>
         <reports>
            <report forceMpc="true" category="basilar" />
            <report forceMpc="true" category="informative" />
            <report forceMpc="true" category="concluding" />
         </reports>
      </olqcGipp>
   </Data_Block>
</Earth_Explorer_File>
